# 📚 Ext JS 개발 가이드 목차 🌟

- 🌈 [Ext JS 기본 컴포넌트 가이드](#🌟-ext-js-기본-컴포넌트-가이드-🌈)
    - 📝 [Ext JS 컴포넌트 기본 소개](#🛠-기본-컴포넌트-소개-🎯)
- 📄 [Ext JS 예제 페이지 기본 구조](#📖-ext-js-페이지-기본-구조-📄)
    - 🔍 [Ext JS 애플리케이션의  예제 (index.html) HTML 구조 설명](#📑-ext-js-애플리케이션의-indexhtml-html-구조-설명-🌟)
- 💡[Ext JS 애플리케이션 예제 코드(index.js) 분석](#🌟ext-js-애플리케이션-예제-코드indexjs-분석-📘)
- 🌈[Ext JS 컨테이너와 레이아웃](#🌟-ext-js-컨테이너와-레이아웃-🌈)
- 🌈[Ext JS 이벤트와 컴포넌트 접근](#🌟-ext-js-이벤트와-컴포넌트-접근🌈)
-  
---

# 🌟 Ext JS 기본 컴포넌트 가이드 🌈

### Ext JS는 방대한 UI 컴포넌트 라이브러리를 제공하며, 이는 개발 과정에서 필수적인 자산. 여기서는 Ext JS에서 제공하는 주요 기본 컴포넌트들을 소개하고, 실습 준비 방법에 대해 안내. 🚀

# 🛠 기본 컴포넌트 소개 🎯

- **Panel (`Ext.panel.Panel`)**: 🖼 다양한 UI 구성 요소를 담을 수 있는 컨테이너. 레이아웃 및 이벤트 관리에 최적화.
- **TextField (`Ext.form.field.Text`)**: 📝 사용자로부터 텍스트 입력을 받는 필드. 비밀번호, 이메일 등 다양한 입력 유형을 처리할 수 있음.
- **DateField (`Ext.form.field.Date`)**: 📅 사용자가 날짜를 선택할 수 있는 달력 기반 필드.
- **ComboBox (`Ext.form.field.ComboBox`)**: 🔽 사용자가 드롭다운 목록에서 선택할 수 있는 필드. 사용자 정의 옵션 목록을 제공합니다.
- **Grid (`Ext.grid.Panel`)**: 📊 데이터를 그리드 형태로 표시합니다. 정렬, 필터링 등 다양한 데이터 관리 기능을 지원.
- **Tree (`Ext.tree.Panel`)**: 🌲 계층적 데이터를 트리 구조로 표시하는 컴포넌트.
- **Button (`Ext.button.Button`)**: 🖱️ 사용자 인터랙션을 위한 버튼을 생성합니다. 클릭 이벤트 처리를 통해 다양한 작업을 수행할 수 있습니다.
- **Window (`Ext.window.Window`)**: 🏠 독립적인 윈도우를 생성합니다. 모달 및 비모달 창으로 활용할 수 있음.

## 📚 컴포넌트 사용을 위한 참고 자료

Ext JS 컴포넌트들은 그 기능이 매우 방대하기 때문에, [Ext JS 공식 문서](https://docs.sencha.com/extjs/7.0.0/classic/Ext.form.field.Date.html)에서 필요한 컴포넌트를 검색하고, 그 사용법을 익히는 것이 좋음. 🕵️‍♂️

## 🌐 실습 준비하기

1. **폴더 생성**: `C:\WorkspaceExtjs`에 `BasicWidgets` 폴더를 만듦. 📁
2. **필수 파일 복사**: `BasicWidgets`에 CSS 파일과 `ext-all-debug.js` 파일을 복사. 📋
3. **실습 폴더 및 파일 생성**: `BasicWidgets` 내에 `BasicComp` 폴더를 만들고, 이 폴더 안에 `index.html`과 `index.js` 파일을 생성. ✨
4. **VSCode로 작업 공간 열기**: VSCodegit add를 실행하여 `BasicWidgets` 폴더를 열고 실습을 준비. 🖥
---

#  📖 Ext JS 페이지 기본 구조 📄

### HTML 문서의 기본 구조와 함께 Ext JS 라이브러리와 CSS를 포함하는 방법에 대해 알아보자.

## 📑 페이지 구조와 핵심 요소

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="../BasicClassicApp-all.css">
    <script language="javascript" src="../ext-all-debug.js"></script>
    <script language="javascript" src="index.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    
</body>
</html>
```
#  📑 Ext JS 애플리케이션의 (index.html) HTML 구조 설명 🌟

앞서 제공된 HTML 템플릿은 Ext JS 애플리케이션 개발의 기본 출발점. 여기서 사용된 Ext JS의 기본 CSS와 JavaScript 파일을 연결하는 방법을 아래와 같이 자세히 설명.

## 🌐 DOCTYPE 선언
- `<!DOCTYPE html>`: HTML5 표준을 준수함을 선언하여, 현대적인 웹 표준에 맞게 Ext JS 애플리케이션을 개발할 수 있도록 하자.

## 🖥 `<html>` 태그
- 페이지의 전체 내용을 감싸는 루트 요소. 모든 HTML 요소는 이 `<html>` 태그 내부에 위치해야 합니다.

## 📚 `<head>` 섹션
- 페이지의 메타 데이터, 외부 리소스 링크, 스크립트 등을 정의하는 섹션.

### 🔤 문자 인코딩 설정
- `<meta charset="UTF-8">`: 페이지의 문자 인코딩을 UTF-8로 설정하여 글로벌 언어 지원을 최적화.

### 📄 문서 제목
- `<title>Document</title>`: 브라우저 탭에서 표시될 문서의 제목을 설정.

### 🎨 CSS 스타일시트 링크
- `<link rel="stylesheet" type="text/css" href="../BasicClassicApp-all.css">`: Ext JS 애플리케이션에 적용될 기본 스타일을 정의한 CSS 파일을 문서에 연결. 이 CSS 파일은 Ext JS 컴포넌트의 스타일을 포함하고 있음.

### 📜 JavaScript 파일
- Ext JS 라이브러리(`ext-all-debug.js`)와 애플리케이션의 메인 JavaScript 파일(`index.js`)을 페이지에 포함시킵니다. `ext-all-debug.js`는 디버깅에 유용한 정보를 제공하는 Ext JS 라이브러리의 버전.

### 🖥️ 반응형 웹 디자인
- `<meta name="viewport" content="width=device-width, initial-scale=1.0">`: 페이지가 다양한 디바이스와 화면 크기에 적절하게 응답하도록 설정.

## 📱 `<body>` 섹션
- 실제 페이지 콘텐츠와 Ext JS로 구성된 UI 컴포넌트를 포함할 부분. 여기에 정의된 JavaScript 코드를 통해 동적인 사용자 인터페이스를 구성하고 Ext JS의 강력한 기능을 활용.

### 이 구조를 이해하고 적용함으로써, Ext JS 애플리케이션 개발을 효율적으로 진행할 수 있으며, Ext JS의 다양한 UI 컴포넌트와 기능을 최대한 활용할 수 있음.
---


# 🌟Ext JS 애플리케이션 예제 코드(index.js) 분석 📘
## Ext.onReady(...) 함수 설명

### 🚀 기능
#### `Ext.onReady(function(){...});`는 Ext JS 프레임워크에서 제공하는 핵심 메서드입니다. 이 메서드는 웹 페이지의 모든 리소스가 로드되고 나서, 즉 문서의 DOM이 완전히 구성된 후에 실행될 JavaScript 코드를 정의하는 데 사용됨. 

### 🔍 상세
- **중요도:** 🌟🌟🌟
- 이 메서드는 애플리케이션의 시작점 역할을 함. 여기서 애플리케이션에 필요한 데이터를 불러오거나, UI 컴포넌트를 초기화하는 등의 작업을 수행할 수 있음.
- Ext JS를 사용한 웹 애플리케이션 개발 시, 페이지 로딩이 완료되고 사용자에게 UI를 제공하기 전에 필요한 모든 초기 설정 작업을 이 곳에서 처리.

### 🎯 사용 예
```javascript
Ext.onReady(function(){
    // DOM이 준비되었으므로, 여기서 UI 컴포넌트를 생성하거나 초기화 작업을 수행할 수 있습니다.
    Ext.create('Ext.Button', {
        text: 'Click me',
        renderTo: Ext.getBody(),
        handler: function() {
            alert('Button clicked!');
        }
    });
});

// 위 예제에서는 Ext.onReady 내부에서 Ext JS의 버튼 컴포넌트를 생성. 버튼이 클릭되면 간단한 알림(alert) 메시지를 보여줌.
```

### 💡 비전공자를 위한 추가 설명
#### 웹 페이지가 사용자에게 보여지기 전에, 페이지의 모든 요소가 제대로 로드되고 준비되었는지 확인하는 단계가 필요함. Ext.onReady(...)는 바로 그런 준비 단계를 안전하게 처리할 수 있는 방법을 제공.
#### 단순히 문서가 로드되기를 기다리는 것 뿐만 아니라, Ext JS 프레임워크와 함께 사용될 다양한 컴포넌트들이 올바르게 작동할 수 있는 환경을 만들어줌.
---

## Ext.panel.Panel (패널 컴포넌트)
- **중요도:** 🌟🌟🌟🌟
- **기능:** Ext JS에서 가장 기본적인 컨테이너 컴포넌트로, 다양한 UI 요소들을 그룹화하고 관리하는 데 사용됩니다. 패널은 텍스트, HTML 콘텐츠, 다른 Ext JS 컴포넌트들을 포함할 수 있으며, 탭, 툴바, 버튼 등의 추가 기능을 통해 상호작용적인 사용자 인터페이스를 구성할 수 있음.

### 🛠 구성 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'My Panel', // 패널의 제목을 설정.
    width: 600, // 패널의 너비를 지정.
    height: 400, // 패널의 높이를 지정.
    renderTo: Ext.getBody() // 패널을  body에 렌더링 // // document.body
    layout: 'fit', // 패널 내부 컴포넌트의 레이아웃을 정의.
    items: [{ // 패널에 포함할 자식 컴포넌트들을 배열로 정의.
        xtype: 'grid', // 예를 들어, 그리드 컴포넌트를 자식으로 포함할 수 있음.
        columns: [...], // 그리드의 컬럼 설정
        store: {...} // 그리드에 데이터를 제공하는 스토어 설정
    }]
});
// 이 예제에서는 기본적인 패널을 생성하고, 그 내부에 그리드 컴포넌트를 자식으로 포함시키는 방법을 보여줌. 패널의 layout을 'fit'으로 설정하면, 내부 컴포넌트는 패널의 전체 영역을 차지하도록 확장됨.
```
## 💡 비전공자를 위한 추가 설명
#### 패널은 웹 페이지 내에서 여러 요소들을 하나의 단위로 묶어서 관리하고자 할 때 유용한 컴포넌트. 예를 들어, 사용자 정보를 입력받는 양식, 상품 목록을 보여주는 테이블 등을 패널 안에 배치하여, 웹 애플리케이션의 구조를 명확하고 깔끔하게 구성할 수 있음.
#### 패널은 그 자체로도 유용하지만, `items` 속성을 통해 다른 컴포넌트들을 포함시켜 더 복잡한 레이아웃을 구성하는 기반으로 사용됩니다. 패널의 `title`, `width`, `height`와 같은 속성을 통해 외관과 크기를 쉽게 조절할 수 있으며, 필요에 따라 추가적인 UI 요소(예: 버튼, 툴바)를 통합할 수 있음.
---

## Ext.create 함수 상세 설명

### 🛠 기능
#### `Ext.create` 함수는 Ext JS 프레임워크에서 UI 컴포넌트나 다른 객체를 동적으로 생성할 때 사용됩니다. 이 메서드를 통해 클래스의 인스턴스를 만들고, 필요한 초기 설정을 적용할 수 있습니다.

### 🔍 상세
- **중요도:** 🌟🌟🌟
- `Ext.create`는 클래스 이름과 객체 설정을 매개변수로 받아, 해당 클래스의 새 인스턴스를 생성. 생성된 인스턴스는 즉시 사용할 수 있으며, Ext JS 애플리케이션 내의 다양한 위치에서 참조.
- 이 메서드는 애플리케이션의 유연성과 확장성을 크게 향상시킴. 개발자는 런타임 시에 필요한 컴포넌트를 생성하고, 조건에 따라 다양한 설정을 적용 가능.

### 🎯 사용 예
```javascript
Ext.create('Ext.form.TextField', {
    fieldLabel: '이름',
    renderTo: Ext.getBody() // document.body
});
// 위 예제는 텍스트 입력 필드를 생성하고, 웹 페이지의 본문에 그 필드를 렌더링. fieldLabel은 입력 필드 옆에 표시될 라벨을 지정.
```

## 💡 비전공자를 위한 추가 설명
#### Ext.create 함수는 Ext JS에서 매우 자주 사용되는 핵심 메서드 중 하나. 웹 페이지에 표시할 버튼, 텍스트 필드, 패널 등 다양한 UI 컴포넌트를 만드는 데 사용됨.
#### 사용자가 인터페이스와 상호작용할 수 있는 요소를 프로그래밍 방식으로 쉽게 추가하고, 그 요소들을 원하는 대로 조절할 수 있게 해줌. 예를 들어, 사용자의 액션에 따라 새로운 입력 필드를 페이지에 추가하거나, 특정 이벤트가 발생했을 때 팝업 창을 표시하는 등의 동작을 구현할 수 있음.
---

## Ext.form.field.Text (텍스트 필드)
- **중요도:** 🌟🌟🌟🌟
- **기능:** 사용자로부터 문자열 입력을 받기 위한 기본적인 입력 필드. 폼 내에서 사용자의 데이터 입력을 받는 데 주로 사용.

### 🛠 구성 예시
```javascript
Ext.create('Ext.form.field.Text', {
    fieldLabel: '이름', // 입력 필드 옆에 표시될 라벨을 설정
    allowBlank: false, // 입력 필드가 비어 있을 수 없음을 나타냄
    maxLength: 50, // 입력 가능한 최대 문자 수를 지정
    renderTo: Ext.getBody() // 텍스트 필드를 문서의 body에 렌더링.
});
// 이 예제에서는 사용자의 이름을 입력받기 위한 텍스트 필드를 생성. fieldLabel을 통해 입력 필드 옆에 '이름'이라는 라벨이 표시되며, allowBlank: false 설정으로 사용자가 반드시 이 필드를 채워야 함을 요구.
```

## 💡 비전공자를 위한 추가 설명
#### 텍스트 필드는 웹 폼에서 가장 자주 사용되는 요소 중 하나. 사용자가 웹사이트에 정보(예: 이름, 이메일 주소, 검색어 등)를 입력할 때 사용.
#### 텍스트 필드는 입력받은 데이터를 서버로 전송하기 전에 사용자 인터페이스에 임시로 저장하는 역할을 함. 예를 들어, 회원 가입 양식에서 사용자의 이름을 입력 받거나, 검색 엔진에서 검색어를 입력 받는 데 사용할 수 있음.
#### `allowBlank`: `false`와 같은 속성을 사용하여 입력 필드의 유효성 검사 규칙을 설정할 수 있음. 이를 통해, 사용자가 올바른 형태의 데이터를 입력하도록 요구할 수 있으며, 필수 입력 사항을 지정할 수도 있음.
#### `maxLength` 속성을 설정함으로써, 입력 필드에 입력할 수 있는 문자의 수를 제한할 수 있음. 이는 사용자가 너무 많은 데이터를 입력하는 것을 방지하고, 데이터 처리 시 발생할 수 있는 문제를 미리 방지하는 데 도움이 됨.
---

## Ext.form.field.Date (날짜 필드)
- **중요도:** 🌟🌟🌟🌟
- **기능:** 사용자로부터 날짜 입력을 받는 필드. 달력 팝업을 제공하여 사용자가 특정 날짜를 쉽게 선택할 수 있음.

### 🛠 구성 예시
```javascript
Ext.create('Ext.form.field.Date', {
    fieldLabel: '생년월일', // 입력 필드 옆에 표시될 라벨
    name: 'birthday', // 폼 데이터를 서버로 전송할 때 사용될 필드의 이름
    allowBlank: false, // 이 필드를 필수 입력 필드로 설정
    maxValue: new Date(), // 선택할 수 있는 최대 날짜를 오늘로 설정
    renderTo: Ext.getBody() // 날짜 필드를 문서의 body에 렌더링
});
// 이 예제에서는 사용자의 생년월일을 입력받기 위한 날짜 필드를 생성. fieldLabel로 '생년월일'이라는 라벨을 설정하고, allowBlank: false를 통해 필수 입력 필드로 지정. maxValue 설정으로 사용자가 오늘 이후의 날짜를 선택할 수 없게 함.
```
## 💡 비전공자를 위한 추가 설명
#### 날짜 필드는 웹 폼에서 사용자에게 특정 날짜를 입력받아야 할 때 사용. 예를 들어, 온라인 예약 시스템에서 예약 날짜를 선택하거나, 개인 정보를 입력할 때 생년월일을 입력하는 경우에 활용됨.
#### 날짜 필드는 달력 팝업을 제공하여, 사용자가 날짜를 직접 입력하는 대신 달력에서 날짜를 선택할 수 있게 함. 이는 사용자가 날짜 형식에 신경 쓰지 않고도 손쉽게 날짜를 입력할 수 있게 해줌.
#### maxValue와 같은 속성을 설정하여 입력 가능한 날짜의 범위를 제한할 수 있음. 이를 통해, 미래의 날짜나 과거의 특정 시점 이전의 날짜를 선택하지 못하게 할 수 있음.
#### 날짜 필드를 사용하면 폼 데이터의 유효성 검사를 손쉽게 할 수 있으며, 사용자에게 더 나은 입력 경험을 제공할 수 있음.
---



## Ext JS의 `items` 배열과 `xtype` 속성

### 📦 items 배열
- **중요도:** 🌟🌟🌟
- **기능:** `items` 속성은 Ext JS 컨테이너 컴포넌트(예: 패널) 내에 포함될 자식 컴포넌트들의 배열을 정의합니다. 이 배열에 포함된 각 컴포넌트는 컨테이너 내에 순차적으로 배치.
- **설명:** 컨테이너 컴포넌트는 여러 개의 자식 컴포넌트를 그룹화하고 관리할 수 있음. `items` 배열을 사용하여 이러한 자식 컴포넌트들을 정의하고, 컨테이너에 추가. 각 아이템은 컴포넌트의 구체적인 타입(`xtype`), 설정, 레이아웃 등을 포함할 수 있음.

### 🛠 xtype 속성
- **중요도:** 🌟🌟🌟
- **기능:** `xtype` 속성은 컴포넌트의 별칭(alias)을 지정하여, 해당 타입의 컴포넌트를 생성할 때 사용됨. `xtype`을 사용함으로써, 개발자는 클래스 이름을 명시하지 않고도 컴포넌트를 간편하게 지정할 수 있음.
- **설명:** `xtype`은 Ext JS 프레임워크 내에서 사전 정의된 컴포넌트 타입을 참조하기 위한 간단한 방법입니다. 예를 들어, `'textfield'`, `'button'`, `'grid'` 등이 있고, 컨테이너의 `items` 배열 내에서 `xtype`을 사용하여 필요한 컴포넌트를 쉽게 추가할 수 있음.

### 🎯 사용 예
```javascript
{
    xtype: 'panel',
    items: [
        {
            xtype: 'textfield',
            fieldLabel: '이름'
        },
        {
            xtype: 'datefield',
            fieldLabel: '날짜'
        },
        {
            xtype: 'button',
            text: '확인'
        }
    ]
}
// 위 예제는 xtype을 사용하여 텍스트 필드, 날짜 필드, 버튼을 포함하는 패널을 정의. 이 방식을 통해 각 컴포넌트의 타입을 간단하게 지정하고, 필요한 설정을 적용할 수 있음.
```
## 💡 비전공자를 위한 추가 설명
#### `items` 배열과 `xtype` 속성을 활용하면, 웹 애플리케이션의 인터페이스를 구성하는 여러 컴포넌트를 쉽게 조합하고 구성할 수 있음. 이는 마치 레고 블록을 조립하듯, 필요한 UI 요소들을 선택하고, 조합하여 사용자에게 제공하는 페이지를 만드는 과정과 유사.
---

## Ext JS에서의 `handler` 함수

### 🎯 기능
- **중요도:** 🌟🌟🌟
- `handler` 함수는 Ext JS의 이벤트 핸들러로 사용됨. 주로 버튼 클릭과 같은 사용자 액션에 반응하여 특정 코드를 실행하기 위해 정의.

### 🔍 상세
- `handler` 속성은 컴포넌트(대부분 버튼)에 지정되며, 해당 컴포넌트가 클릭되었을 때 실행할 JavaScript 함수를 정의합니다. 이 함수 내에서는 다양한 로직을 구현할 수 있으며, 예를 들어 사용자에게 메시지를 표시하거나, 다른 뷰로의 네비게이션, 데이터의 처리 등의 작업을 수행할 수 있음.

### 📝 사용 예
```javascript
{
    xtype: 'button',
    text: '클릭',
    handler: function() {
        Ext.Msg.alert('알림', '버튼이 클릭되었습니다!');
    }
}
// 위 예제에서는 버튼 컴포넌트를 정의하고, 해당 버튼이 클릭될 때 간단한 알림 메시지를 보여주는 handler 함수를 구현.
```

## 💡 비전공자를 위한 추가 설명
#### 웹 페이지에서 버튼과 같은 요소를 클릭했을 때 특정 행동을 하게 만들고 싶다면, 그 행동을 정의하는 함수를 만들어야 합니다. handler 함수는 바로 그런 역할을 하는 Ext JS의 방법 중 하나. 쉽게 말해, `handler`는 "이 버튼을 누르면 이 일을 해라"라고 컴퓨터에게 지시하는 역할을 함.
#### 이러한 방식으로 handler를 사용하면, 사용자의 입력에 따라 다양한 반응을 쉽게 프로그래밍할 수 있습니다. 이는 웹 애플리케이션을 더 동적이고 상호작용적으로 만드는 데 중요한 기능.
---

## Ext.form.field.ComboBox 예시와 Store 상세 설명

### 📌 ComboBox 컴포넌트
- **기능:** 사용자가 여러 옵션 중 하나를 선택할 수 있는 드롭다운 목록을 제공.
- **중요도:** 🌟🌟🌟

### 🛠 구성 예시
```javascript
{
    xtype: 'combobox', // 컴포넌트 타입 지정
    fieldLabel: '선택', // 라벨 표시
    labelWidth: 60, // 라벨 너비 설정
    width: 200, // 컴포넌트 전체 너비 설정
    valueField: 'value', // 선택된 항목의 '실제 값'을 나타내는 필드
    displayField: 'display', // 사용자에게 보여지는 '텍스트'를 나타내는 필드
    store: { // 콤보 박스의 데이터를 제공하는 스토어 설정
        fields: ['value', 'display'], // 스토어에 포함될 데이터 모델의 필드 정의
        data: [ // 실제 데이터 목록
            { value: '1', display: '홍길동' },
            { value: '2', display: '임꺽정' },
            { value: '3', display: '유관순' },
            { value: '4', display: '이순신' }
        ]
    }
}
```

## 💡 Store 상세 설명
역할: `store`는 `Ext JS`에서 데이터 컬렉션을 관리하는 컴포넌트. `ComboBox`와 같은 데이터 기반 `UI` 컴포넌트에 데이터를 공급하는 역할을 함.
`fields`: 스토어에서 사용할 데이터 모델의 필드를 정의합니다. 여기서는 각 데이터 항목이 `value`와 `display`라는 두 필드를 갖도록 설정. `value`는 데이터의 실제 값을, display는 사용자에게 보여질 문자열을 나타냄.
`data`: 스토어의 실제 데이터 항목을 배열로 정의합니다. 각 객체는 `fields`에 정의된 필드에 해당하는 값을 갖습니다. 이 데이터는 ComboBox에서 사용자에게 보여질 선택 가능한 옵션들.
## 💡 비전공자를 위한 추가 설명
`store`를 이해하기 쉽게 말하자면, 콤보 박스나 리스트와 같이 여러 데이터를 보여주는 `UI` 컴포넌트에 "무엇을 보여줄지"를 정의하는 데이터의 집합.
예를 들어, 쇼핑몰의 드롭다운 메뉴에서 상품 카테고리를 선택하는 경우, 각 카테고리의 이름`(display`)과 그에 해당하는 고유 번호(`value`)를 `store`에 정의하여 관리할 수 있음. 사용자는 이름을 보고 선택하지만, 시스템은 고유 번호로 해당 카테고리를 식별.
---

## Ext.grid.Panel (그리드 컴포넌트)
- **중요도:** 🌟🌟🌟
- **기능:** 복수의 데이터를 테이블 형태로 보여주는 컴포넌트입니다. 데이터를 구조화된 형태로 표시하고자 할 때 사용됨.

### 🛠 구성 예시
```javascript
{
    xtype: 'grid', // 그리드 컴포넌트의 xtype을 지정.
    width: 300, // 그리드의 너비를 설정.
    height: 300, // 그리드의 높이를 설정.
    store: { // 그리드에 표시될 데이터를 관리하는 스토어를 정의.
        fields: ['value', 'display'], // 스토어에서 관리될 데이터의 필드를 정의.
        data: [ // 스토어의 실제 데이터 항목들을 배열로 정의.
            { value: '1', display: '홍길동' },
            { value: '2', display: '임꺽정' },
            { value: '3', display: '유관순' },
            { value: '4', display: '이순신' },
            { value: '5', display: '강감찬' }
        ]
    },
    columns: [ // 그리드에 표시될 컬럼들을 정의.
        {
            text: '값', // 컬럼의 헤더에 표시될 텍스트.
            dataIndex: 'value', // 이 컬럼에서 표시될 데이터의 필드명.
            width: 100 // 컬럼의 너비를 설정.
        },
        {
            text: '보여주는항목', // 두 번째 컬럼의 헤더 텍스트.
            dataIndex: 'display', // 이 컬럼에서 표시될 데이터의 필드명.
            flex: 1 // 이 컬럼이 남은 공간을 모두 차지.
        }
    ]
}
// 이 예제에서는 각 사람의 고유 번호(value)와 이름(display)을 데이터로 사용하고 있음. 그리드는 이 데이터를 구조화하여 테이블 형태로 보여줌.
```
## 💡 비전공자를 위한 추가 설명
#### 그리드는 흔히 엑셀과 같은 스프레드시트를 떠올리게 하는 데이터 표시 방법입니다. 각 행은 데이터의 한 항목을 나타내며, 각 열은 그 데이터의 속성(예: 이름, 이메일 등)을 나타냅니다.

#### `store`는 그리드가 데이터를 어디서 가져올지, 그리고 어떤 데이터를 가져올지 정의하는 곳. `fields`에서는 데이터의 구조를 정의하고, `data`에서는 실제 표시될 데이터를 제공.
#### `columns`에서는 그리드의 열을 어떻게 구성할지 정의. text는 열의 제목을, dataIndex는 그 열이 어떤 데이터를 표시할지를 결정. flex: 1은 해당 열이 남은 가용 공간을 모두 차지하도록 함, 즉 유동적으로 크기가 조정됨.
---

## Ext.tree.Panel (트리 패널 컴포넌트)
- **중요도:** 🌟🌟🌟
- **기능:** 계층적 데이터를 트리 구조로 보여주는 컴포넌트. 각 항목은 노드라고 하며, 부모-자식 관계를 가질 수 있음.

### 🛠 구성 예시
```javascript
{
    xtype: 'treepanel', // 트리 패널 컴포넌트의 xtype을 지정.
    width: 300, // 트리 패널의 너비를 설정.
    height: 300, // 트리 패널의 높이를 설정.
    store: { // 트리 패널에 표시될 데이터를 관리하는 스토어를 정의.
        root: { // 스토어의 루트 노드를 정의합.
            expanded: true, // 루트 노드가 처음부터 확장(열림) 상태인지를 결정.
            children: [ // 루트 노드의 자식 노드들을 정의.
                {text: '일', leaf: true}, // 'leaf: true'는 더 이상 자식이 없는 최종 노드임을 의미.
                {text: '이', leaf: true}, // 각 노드는 'text' 속성으로 라벨을 가짐.
                {
                    text: '삼', leaf: false, // 'leaf: false'는 이 노드가 자식 노드를 가질 수 있음을 의미합.
                    children: [ // '삼' 노드의 자식 노드들을 정의.
                        {text: '삼-일', leaf: true},
                        {text: '삼-이', leaf: true}
                    ]
                }
            ]
        }
    },
    rootVisible: false, // 루트 노드 자체를 트리 패널에 표시할지 결정. 'false'는 루트 노드를 숨김.
}
```
## 💡 비전공자를 위한 추가 설명
#### 트리 패널은 파일 시스템 탐색기나 조직도와 같은 계층적 구조를 시각적으로 표현할 때 사용. 각 항목(노드)은 다른 항목의 부모 또는 자식이 될 수 있으며, 이를 통해 계층 구조를 나타냄.
#### 예를 들어, '삼'이라는 항목 아래에 '삼-일'과 '삼-이'라는 자식 항목이 있을 때, 이들은 트리 구조에서 '삼'의 자식 노드로 표시됨. 사용자는 '삼' 항목을 클릭하여 자식 항목들을 보거나 숨길 수 있음.
#### `rootVisible: false` 설정은 트리의 최상위 항목을 숨기고, 그 자식 항목들만을 표시하고자 할 때 유용. 이는 사용자에게 보여질 필요가 없는 최상위 레벨의 정보를 숨기기 위해 사용됨.
---

## Ext.window.Window (윈도우 컴포넌트)
- **중요도:** 🌟🌟🌟🌟
- **기능:** 독립적인 윈도우 형태의 UI를 생성하여, 다양한 내용을 팝업 형식으로 사용자에게 보여주는 컴포넌트.

### 🛠 구성 예시
```javascript
let window = Ext.create('Ext.window.Window', {
    title: '윈도우', // 윈도우의 제목
    width: 400, // 윈도우의 너비
    height: 300, // 윈도우의 높이
    items: [{ // 윈도우 내부에 배치될 컴포넌트들
        xtype: 'textfield', // 텍스트 필드 컴포넌트
        fieldLabel: '텍스트' // 텍스트 필드의 라벨
    }]
});
window.show(); // 윈도우를 화면에 표시

// 이 예제에서는 Ext.window.Window를 사용하여 기본 설정(제목, 크기, 내부 컴포넌트)이 적용된 윈도우를 생성하고, .show() 메서드를 호출하여 화면에 표시.
```

## 💡 윈도우 컴포넌트 상세 설명
#### 윈도우 크기와 위치: 윈도우의 `width`와 `height` 속성으로 크기를 지정할 수 있습니다. 또한, `x`와 `y` 속성을 통해 화면 내에서의 위치를 정할 수도 있음.
#### 내부 컴포넌트: `items` 배열을 사용하여 윈도우 내부에 다양한 컴포넌트(예: 텍스트 필드, 버튼, 그리드 등)를 배치할 수 있음. 각 컴포넌트는 `xtype` 속성을 통해 지정됨.
#### 모달 윈도우: `modal` 속성을 `true`로 설정하면, 윈도우가 활성화되어 있는 동안 기타 `UI` 요소와의 상호작용을 차단할 수 있음. 이는 사용자의 주의를 특정 작업에 집중시키고자 할 때 유용.
#### 닫기 및 최소화/최대화: 윈도우는 사용자가 직접 닫거나 최소화/최대화할 수 있는 컨트롤을 제공. 이는 윈도우의 상단 툴바에 기본적으로 포함되어 있음.
## 💡 비전공자를 위한 추가 설명
#### `Ext.window.Window`는 웹 애플리케이션에서 별도의 팝업 창을 생성할 때 사용되는 컴포넌트. 예를 들어, 사용자에게 폼을 채우도록 요청하거나, 중요한 정보를 알림 형식으로 보여주고자 할 때 이 컴포넌트를 활용할 수 있음.
#### 윈도우 내부에는 사용자와의 상호작용을 위한 다양한 요소를 배치할 수 있으며, 이를 통해 동적이고 상호작용적인 사용자 경험을 제공할 수 있음.
---
# 🌟 Ext JS 컨테이너와 레이아웃 🌈

## Layout: 'absolute' (절대적 레이아웃)

- **중요도:** 🌟🌟🌟
- **기능:** 컴포넌트의 위치를 절대 좌표로 지정하여, 컨테이너 내에서 정확한 위치에 배치할 수 있는 레이아웃.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    width: 500,
    height: 400,
    layout: 'absolute', // 절대적 레이아웃을 사용.
    items: [
        {
            xtype: 'textfield',
            fieldLabel: '이름',
            x: 50, // 패널의 왼쪽 가장자리로부터 50픽셀 떨어진 위치에 배치.
            y: 50, // 패널의 상단 가장자리로부터 50픽셀 떨어진 위치에 배치.
            width: 200
        },
        {
            xtype: 'button',
            text: '버튼',
            x: 50, // 동일한 x 좌표에 버튼을 배치하여 텍스트 필드 바로 아래에 위치.
            y: 100, // 텍스트 필드보다 50픽셀 아래에 위치.
            width: 100
        }
    ],
    renderTo: Ext.getBody()
});
// 이 예제에서는 절대적 레이아웃을 사용하여 패널 내의 텍스트 필드와 버튼을 정확한 위치에 배치. 각 컴포넌트는 x와 y 속성을 통해 좌표를 지정.
```
## 💡 비전공자를 위한 추가 설명
#### `absolute` 레이아웃은 웹 페이지 디자인에서 각 요소를 픽셀 단위로 정확히 제어하고자 할 때 유용합니다. 이를 통해, 디자이너는 컴포넌트를 원하는 정확한 위치에 배치할 수 있음.
### 하지만, `absolute` 레이아웃을 사용할 때는 반응형 디자인에 유의. 고정된 위치에 배치된 컴포넌트들은 화면 크기가 변할 때 자동으로 위치가 조정되지 않기 때문에, 다양한 디스플레이 환경에서의 호환성을 고려한 추가적인 처리가 필요할 수 있음.
#### 절대적 레이아웃은 복잡한 레이아웃을 구현해야 하거나, 특정 요소를 다른 요소와 겹치게 하려는 경우와 같이, 특별한 레이아웃 요구사항이 있을 때 선택적으로 사용됨.
---

## Layout: 'fit' (화면 채우기 레이아웃)

- **중요도:** 🌟🌟🌟🌟
- **기능:** 한 개의 자식 컴포넌트만을 포함하며, 해당 자식 컴포넌트를 컨테이너의 전체 크기로 확장하여 화면을 꽉 채우게 하는 레이아웃.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'Fit Layout Panel',
    width: 300,
    height: 150,
    layout: 'fit', // 'fit' 레이아웃을 사용.
    items: [
        {
            xtype: 'panel', // 내부 패널
            html: '내부 컨텐츠는 이 패널을 꽉 채움.'
        }
    ],
    renderTo: Ext.getBody()
});
// 위 예제에서는 외부 패널이 fit 레이아웃을 사용하여 내부에 단 하나의 패널을 포함하고 있고. 내부 패널은 외부 패널의 전체 크기로 자동 조정되어, 화면을 꽉 채우게 됨.
```

## 💡 비전공자를 위한 추가 설명
#### `fit` 레이아웃은 단순하지만 강력한 레이아웃 방식. 주로 전체 화면의 콘텐츠를 표시하거나, 어플리케이션의 메인 뷰를 구성할 때 사용.
#### 예를 들어, 어플리케이션에 메인 콘텐츠 영역이 하나만 있고, 이 영역이 화면 전체를 차지해야 할 때 `fit` 레이아웃이 유용하게 사용될 수 있음.
#### `fit` 레이아웃을 사용하는 컨테이너는 한 번에 하나의 컴포넌트만을 보여줄 수 있습니다. 만약 여러 개의 컴포넌트를 동시에 표시하려면 다른 레이아웃을 고려해야 함.
#### 이 레이아웃은 특히 반응형 디자인에서 유리. 컨테이너의 크기가 변하더라도, 내부 컴포넌트는 항상 컨테이너를 꽉 채우도록 자동으로 크기가 조정되기 때문.
---

## Layout: 'anchor' (앵커 레이아웃)

- **중요도:** 🌟🌟🌟
- **기능:** 컴포넌트들을 상대적인 크기로 순서대로 배치할 수 있게 해주는 레이아웃. 각 컴포넌트는 컨테이너의 상단에서부터 순차적으로 붙어서 배치되며, 개별 컴포넌트의 크기는 퍼센트 또는 고정 값으로 지정할 수 있음.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'Anchor Layout Panel',
    width: 500,
    height: 400,
    layout: 'anchor', // 'anchor' 레이아웃을 사용.
    items: [
        {
            xtype: 'textfield',
            fieldLabel: '이름',
            anchor: '100%' // 컨테이너의 너비를 100% 차지하도록 설정.
        },
        {
            xtype: 'textfield',
            fieldLabel: '이메일',
            anchor: '-10' // 컨테이너 너비에서 10픽셀을 제외한 나머지를 차지하도록 설정.
        }
    ],
    renderTo: Ext.getBody()
});
// 위 예제에서는 anchor 레이아웃을 사용하여 두 개의 텍스트 필드를 패널에 추가. 첫 번째 텍스트 필드는 패널의 전체 너비를 차지하도록 설정되어 있으며, 두 번째 텍스트 필드는 패널의 너비에서 10픽셀을 제외한 나머지 너비를 차지하도록 설정되어 있음.
```

## 💡 비전공자를 위한 추가 설명
#### `anchor` 레이아웃은 웹 페이지의 폼 레이아웃을 구성할 때 특히 유용. 이 레이아웃을 사용하면, 폼 필드의 너비를 폼 컨테이너에 따라 유연하게 조정할 수 있어, 다양한 화면 크기에 적응하는 반응형 디자인을 구현하기 쉬움.
#### `anchor` 속성을 사용해 각 컴포넌트의 크기를 퍼센트 값(예: `'100%`)으로 설정하면, 해당 컴포넌트는 부모 컨테이너의 너비에 상대적으로 크기를 조정. 고정 픽셀 값(예: '-10')을 사용하면, 부모 컨테이너 너비에서 해당 픽셀만큼 뺀 나머지 너비를 차지하게 됨.
#### 이런 방식으로 `anchor` 레이아웃을 활용하면, 폼 필드들이 컨테이너의 크기 변화에 따라 동적으로 크기가 조정되어, 사용자에게 일관된 사용 경험을 제공할 수 있음.
---

## Layout: 'column' (컬럼 레이아웃)

- **중요도:** 🌟🌟🌟🌟
- **기능:** 컨테이너 내의 컴포넌트들을 여러 컬럼으로 나누어 배치할 수 있게 해주는 레이아웃. `columnWidth` 속성을 사용하여 각 컴포넌트가 차지할 컨테이너의 상대적인 너비 비율을 지정할 수 있음.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'Column Layout Panel',
    width: 500,
    height: 200,
    layout: 'column', // 'column' 레이아웃을 사용.
    items: [
        {
            xtype: 'panel',
            title: '컬럼 1',
            columnWidth: 0.5, // 전체 컨테이너 너비의 50%를 차지.
            html: '절반의 너비를 가진 첫 번째 컬럼'
        },
        {
            xtype: 'panel',
            title: '컬럼 2',
            columnWidth: 0.5, // 전체 컨테이너 너비의 나머지 50%를 차지.
            html: '절반의 너비를 가진 두 번째 컬럼'
        }
    ],
    renderTo: Ext.getBody()
});
// 위 예제에서는 column 레이아웃을 사용하여 두 개의 패널을 각각 전체 컨테이너 너비의 50%씩 차지하도록 배치. 각 패널은 columnWidth 속성을 통해 상대적 너비 비율을 지정받음.
```

## 💡 비전공자를 위한 추가 설명
#### 컬럼 레이아웃은 웹 페이지를 여러 세로열로 나누어 정보를 구조화하고 싶을 때 유용한 레이아웃 방식. 예를 들어, 메인 콘텐츠와 사이드바, 또는 여러 개의 카드 형태의 정보를 나란히 표시할 때 사용할 수 있음.
#### `columnWidth` 속성은 각 컴포넌트가 컨테이너의 너비 중 어느 정도 비율을 차지할지 결정. 이는 전체 레이아웃이 유동적으로 조정되어야 하는 반응형 디자인에 매우 유용.
#### 컬럼 레이아웃을 사용하면, 화면 크기가 변하더라도 각 컴포넌트의 상대적인 크기 비율은 유지됨. 이를 통해 다양한 화면 크기에서도 일관된 사용자 경험을 제공할 수 있음.
---

## Layout: 'table' (테이블 레이아웃)

- **중요도:** 🌟🌟🌟🌟
- **기능:** 컨테이너 내의 컴포넌트들을 HTML 테이블과 유사한 형태로 배치할 수 있게 해주는 레이아웃. 테이블 레이아웃을 사용하면, 컴포넌트들을 행과 열로 정렬하여 복잡한 레이아웃을 쉽게 구성할 수 있음.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'Table Layout Panel',
    width: 400,
    height: 200,
    layout: {
        type: 'table', // 테이블 레이아웃 타입을 설정.
        columns: 3 // 컴포넌트들을 3열로 배치.
    },
    items: [
        {
            xtype: 'panel',
            html: 'Cell 1',
            colspan: 2 // 이 컴포넌트가 2개 열의 공간을 차지.
        },
        {
            xtype: 'panel',
            html: 'Cell 2'
            // 기본적으로 1열을 차지.
        },
        {
            xtype: 'panel',
            html: 'Cell 3'
        },
        {
            xtype: 'panel',
            html: 'Cell 4',
            colspan: 3 // 이 컴포넌트가 3개 열의 공간을 차지.
        }
    ],
    renderTo: Ext.getBody()
});
// 위 예제에서는 type: 'table'을 설정하여 테이블 레이아웃을 사용하고, columns: 3으로 총 3열로 구성된 테이블 형태를 만듦. colspan 속성을 사용하여 특정 컴포넌트가 차지할 열의 수를 지정할 수 있음.
```

## 💡 비전공자를 위한 추가 설명
#### 테이블 레이아웃은 웹 페이지에서 데이터를 표 형식으로 보여주거나, 여러 항목을 균일하게 정렬할 때 자주 사용됨. HTML에서 <table> 태그를 사용하는 것과 유사하게, Ext JS에서는 type: 'table' 레이아웃으로 이를 구현할 수 있음.
#### `columns` 속성을 통해 컨테이너를 몇 열로 나눌지 지정할 수 있으며, 각 컴포넌트는 하나 이상의 열을 차지할 수 있음. 이때 `colspan` 속성을 사용하여, 하나의 컴포넌트가 여러 열에 걸쳐 배치되도록 할 수 있음.
#### 테이블 레이아웃을 사용함으로써, 복잡한 구조의 UI를 효과적으로 구성하고, 다양한 정보를 사용자에게 직관적으로 표현할 수 있음. 특히, 폼 필드, 정보 패널, 버튼 등 다양한 컴포넌트를 체계적으로 배열할 때 유용.
---

## Layout: 'card' (카드 레이아웃)

- **중요도:** 🌟🌟🌟🌟🌟
- **기능:** 여러 컴포넌트를 같은 영역에 배치하고, 한 번에 하나의 컴포넌트만을 보여주는 레이아웃. 사용자가 네비게이션을 통해 다른 컴포넌트를 전환할 수 있으며, 이를 통해 멀티 스텝 폼, 탭 인터페이스, 마법사 형태의 UI 등을 구현할 수 있음.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'Card Layout Panel',
    width: 300,
    height: 200,
    layout: 'card', // 카드 레이아웃을 사용합니다.
    items: [
        {
            xtype: 'panel',
            title: '첫 번째 카드',
            html: '첫 번째 컨텐츠 영역.'
        },
        {
            xtype: 'panel',
            title: '두 번째 카드',
            html: '두 번째 컨텐츠 영역.'
        }
    ],
    renderTo: Ext.getBody()
});
// 이 예제에서는 card 레이아웃을 사용하여 두 개의 패널(카드)을 생성. 각 카드는 독립된 컨텐츠를 포함하며, 한 번에 하나의 카드만 사용자에게 보여짐.
```

## 💡 비전공자를 위한 추가 설명
#### `card` 레이아웃은 여러 `"페이지"` 또는 `"단계"`를 하나의 컨테이너 안에서 관리할 때 매우 유용. 각 카드는 서로 다른 뷰를 나타내며, 사용자는 주어진 인터페이스를 통해 각 뷰 사이를 전환할 수 있음.
#### 예를 들어, 사용자가 설문조사를 진행하는 경우, 각 질문이 별도의 카드로 표시될 수 있으며, 사용자는 `"다음"` 버튼을 클릭하여 다음 질문으로 이동할 수 있음. 이렇게 하면, 복잡한 정보를 단계별로 나누어서 보여줄 수 있으며, 사용자 경험을 개선할 수 있음.
#### `card` 레이아웃을 사용하는 컨테이너는 내부의 카드들을 자동으로 숨기거나 보여주는 역할을 함. 개발자는 컴포넌트 간의 전환 로직(예: 버튼 클릭 시 다음 카드로 이동)을 구현하여, 사용자가 각 카드를 탐색할 수 있도록 해야 함.
---

## Layout: 'accordion' (아코디언 레이아웃)

- **중요도:** 🌟🌟🌟🌟
- **기능:** 여러 패널을 세로로 나열하고, 각 패널을 확장하거나 축소하여 내용을 보여주는 레이아웃. 아코디언 레이아웃은 한 번에 하나의 패널만 확장되도록 제한되며, 사용자가 다른 패널을 확장하면 이전에 확장된 패널은 자동으로 축소됨.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'Accordion Layout Panel',
    width: 300,
    height: 400,
    layout: {
        type: 'accordion',
        titleCollapse: true, // 패널 제목을 클릭하면 해당 패널이 확장/축소.
        animate: true, // 확장/축소 시 애니메이션 효과를 적용.
        activeOnTop: true // 활성화된 패널을 아코디언의 최상단으로 이동.
    },
    items: [
        {
            xtype: 'panel',
            title: '패널 1',
            html: '패널 1의 내용...'
        },
        {
            xtype: 'panel',
            title: '패널 2',
            html: '패널 2의 내용...'
        },
        {
            xtype: 'panel',
            title: '패널 3',
            html: '패널 3의 내용...'
        }
    ],
    renderTo: Ext.getBody()
});
/// 이 예제에서는 accordion 레이아웃을 사용하여 세 개의 패널을 포함하는 상위 패널을 생성. 각 패널은 제목을 클릭하여 확장/축소할 수 있으며, 한 번에 하나의 패널만 활성화되어 내용을 표시.
```
## 💡 비전공자를 위한 추가 설명
#### 아코디언 레이아웃은 정보를 카테고리별로 구분하여 효율적으로 표시하고 싶을 때 유용한 방식. 사용자는 관심 있는 카테고리의 패널만을 확장하여 내용을 볼 수 있으며, 화면 공간을 절약할 수 있음.
#### `titleCollapse` 속성을 `true`로 설정하면 패널의 제목 부분을 클릭했을 때 해당 패널이 확장/축소되는 기능이 활성화됨. `animate` 속성으로 확장/축소 시 시각적 효과를 줄 수 있으며, `activeOnTop` 속성은 현재 활성화된 패널을 아코디언의 가장 위로 이동시킴.
#### 아코디언 레이아웃은 FAQ 섹션, 설정 메뉴, 다양한 설정 옵션을 제공하는 양식 등 다양한 사용 사례에서 활용될 수 있음. 사용자는 각 섹션의 제목만 보고 원하는 정보를 쉽게 찾을 수 있으며, 상세 내용은 해당 섹션을 확장함으로써 확인할 수 있음.
---

## Layout: 'hbox' (가로 나열 레이아웃)

- **중요도:** 🌟🌟🌟🌟
- **기능:** 컴포넌트들을 가로로 나열하여 배치하는 레이아웃. 이 레이아웃을 사용하면, 컨테이너의 자식 컴포넌트들을 왼쪽에서 오른쪽으로 순차적으로 정렬할 수 있음.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'HBox Layout Panel',
    width: 400,
    height: 200,
    layout: {
        type: 'hbox', // 가로 나열 레이아웃을 사용.
        align: 'stretch' // 자식 컴포넌트들을 컨테이너의 높이에 맞춰 늘림.
    },
    items: [
        {
            xtype: 'panel',
            title: '왼쪽 패널',
            flex: 1, // 남은 공간을 기준으로 비율을 결정.
            html: 'flex: 1'
        },
        {
            xtype: 'panel',
            title: '오른쪽 패널',
            flex: 2, // 남은 공간의 두 배 크기로 설정.
            html: 'flex: 2'
        }
    ],
    renderTo: Ext.getBody()
});
// 이 예제에서는 type: 'hbox' 레이아웃을 사용하여 두 개의 패널을 가로로 나열. flex 속성을 사용하여 두 번째 패널이 첫 번째 패널보다 두 배 더 큰 공간을 차지하도록 설정.
```
## 💡 비전공자를 위한 추가 설명
#### `hbox` 레이아웃은 사용자 인터페이스에서 여러 항목을 가로 방향으로 나란히 배열할 때 매우 유용합니다. 예를 들어, 도구 모음, 메뉴 바, 정보 카드 등을 나란히 배치하는 데 적합.
#### `align`: `'stretch'` 설정은 모든 자식 컴포넌트들이 컨테이너의 높이를 균일하게 차지하도록 함. 이는 각 요소가 깔끔하게 정렬되어 시각적 일관성을 유지하게 해줌.
#### `flex` 속성은 컴포넌트가 차지할 공간의 비율을 결정합니다. 이를 통해, 레이아웃 내에서의 공간 분배를 유연하게 조정할 수 있음. 예를 들어, `flex`: 1은 사용 가능한 공간을 다른 `flex` 값을 가진 항목과 비율에 따라 나누어 차지하라는 의미.
---

## Layout: 'vbox' (세로 나열 레이아웃) 세부 설정

- **중요도:** 🌟🌟🌟🌟
- **기능:** 컴포넌트들을 세로 방향으로 나열하여 배치합. `vbox` 레이아웃은 세로 정렬에 특화되어 있으며, 추가적인 속성을 사용해 더욱 세밀한 레이아웃 조정이 가능.

### 🛠 사용 예시와 세부 속성
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'VBox Layout Panel - Advanced',
    width: 400,
    height: 300,
    layout: {
        type: 'vbox', // 레이아웃 타입을 'vbox'로 지정.
        align: 'stretch', // 가로 방향으로 자식 컴포넌트들을 컨테이너 너비에 꽉 차게 늘림.
        pack: 'start' // 세로 방향으로 자식 컴포넌트들을 컨테이너의 시작 부분(위쪽)에서부터 정렬.
    },
    items: [
        {
            xtype: 'panel',
            title: '상단 패널',
            flex: 1, // 사용 가능한 공간에 대해 다른 컴포넌트와 비율로 나누어 차지.
            html: 'flex: 1'
        },
        {
            xtype: 'panel',
            title: '하단 패널',
            flex: 2, // 남은 공간의 두 배 크기로 설정. (상단 패널의 두 배 크기)
            html: 'flex: 2'
        }
    ],
    renderTo: Ext.getBody()
});
```

### `align`: `'stretch'`는 컴포넌트가 가로 방향으로 컨테이너의 전체 너비를 차지하도록 함. 모든 컴포넌트가 동일한 너비를 갖게 됨.
### `pack`: `'start'`는 컴포넌트들이 컨테이너의 상단부터 시작되도록 정렬. 다른 옵션으로는 `center, end, justify`가 있어, 컴포넌트들의 세로 방향 정렬 방식을 결정할 수 있음.
### `flex` 속성을 사용하여 컴포넌트들이 차지할 세로 공간의 비율을 조정할 수 있습니다. 예를 들어, `flex: 1`이 설정된 컴포넌트는 다른 `flex` 값을 가진 컴포넌트와 비교하여 사용 가능한 공간을 비율에 따라 차지하게 됨.

## 💡 비전공자를 위한 추가 설명
#### `vbox` 레이아웃을 사용하면, 웹 애플리케이션의 세로 방향으로 컨텐츠를 효과적으로 배열할 수 있음. 예를 들어, 양식의 필드나 순차적으로 따라야 하는 지침 등을 나열할 때 유용.
#### `align`과 `pack` 속성을 통해, 컴포넌트들의 정확한 위치와 크기를 조절할 수 있어, 원하는 대로 세밀한 레이아웃 디자인이 가능해짐.
#### `flex` 속성은 특히 다양한 크기의 컨텐츠를 다룰 때 유용. 이를 통해 각 컴포넌트의 상대적인 크기를 쉽게 조정할 수 있으며, 화면 공간을 효율적으로 사용할 수 있음.
---

## Layout: 'border' (보더 레이아웃) with Split

- **중요도:** 🌟🌟🌟🌟🌟
- **기능:** 컨테이너를 여러 영역(북, 남, 동, 서, 중앙)으로 나누고, 각 영역에 컴포넌트를 배치합니다. 추가로, `split` 옵션을 활용하여 인접한 영역 사이에 사용자가 크기를 조절할 수 있는 스플리터 바를 제공. 이를 통해, 보더 레이아웃의 유연성이 향상되며, 사용자는 자신의 필요에 맞게 각 영역의 크기를 동적으로 조정할 수 있음.

### 🛠 사용 예시 (스플릿 추가)
```javascript
Ext.create('Ext.panel.Panel', {
    width: 700,
    height: 500,
    layout: 'border', // 보더 레이아웃 사용
    items: [
        {
            region: 'north',
            height: 100,
            title: '북쪽 영역'
        },
        {
            region: 'west',
            width: 150,
            title: '서쪽 영역',
            collapsible: true, // 영역을 접을 수 있게 설정
            split: true // 서쪽 영역과 중앙 영역 사이에 스플리터 바를 추가
        },
        {
            region: 'center',
            title: '중앙 영역',
            html: '주 콘텐츠 영역'
        }
    ],
    renderTo: Ext.getBody()
});
// region 속성을 통해 컴포넌트가 위치할 영역을 지정. border 레이아웃은 center, north, south, east, west의 5가지 영역으로 구분.
// split: true 설정은 지정된 영역에 스플리터 바를 추가. 사용자는 이 바를 드래그하여 영역의 크기를 조절할 수 있으며, 이로 인해 인접 영역의 크기도 자동으로 조정됨.
```

## 💡 비전공자를 위한 추가 설명

### 보더 레이아웃의 이해
보더 레이아웃은 페이지를 `"지역"`으로 구분하여 다양한 기능을 가진 `UI` 요소들을 효율적으로 배치하는 데 사용됨. 이 구조는 다음과 같이 구성:
- **중앙(`center`):** 메인 콘텐츠가 위치. 일반적으로 가장 중요한 정보나 기능을 이 영역에 배치.
- **주변(`north`, `south`, `east`, `west`):** 보조 콘텐츠나 기능적 요소들이 위치합니다. 탐색 메뉴, 도구 모음, 추가 정보 등을 이 영역들에 배치할 수 있음.

이 레이아웃은 특히 대시보드, 웹 애플리케이션, 관리자 인터페이스와 같이 복잡한 정보를 직관적이고 구조화된 방식으로 제공해야 하는 인터페이스에 적합.

### 스플릿 옵션의 중요성
보더 레이아웃에 `split` 옵션을 추가하면, 인접한 영역 사이에 사용자가 크기를 조절할 수 있는 스플리터 바가 생성됨. 이는 웹 애플리케이션의 사용성을 크게 향상시킴:
- **유연성:** 사용자는 자신의 작업 공간을 자유롭게 조정할 수 있음. 특히, 대형 모니터를 사용하거나 여러 작업을 동시에 처리해야 하는 경우 유용.
- **효율적인 공간 활용:** 스플리터 바를 드래그하여 영역의 크기를 조절함으로써, 사용자는 필요에 따라 화면 공간을 보다 효율적으로 활용할 수 있음.
- **동적인 UI 조정:** 마우스를 사용하여 영역의 너비나 높이를 조절할 수 있어, 동적인 UI 조정이 가능합니다. 이를 통해 사용자 경험이 향상됨.

`collapsible` 옵션과 함께 사용하면, 사용자는 영역을 완전히 숨기거나 필요에 따라 다시 표시할 수 있으며, 스플리터 바를 통해 영역의 크기를 세밀하게 조정할 수 있음. 이러한 기능 조합은 정보를 표시하는 대시보드, 복잡한 양식, 에디터 인터페이스 등 다양한 애플리케이션에 적합함.

### 결론
보더 레이아웃과 `split` 옵션의 조합은 사용자에게 다이나믹하고 유연한 인터페이스 조정 기능을 제공함. 복잡한 웹 애플리케이션 구성에서 사용성과 접근성을 향상시키는 중요한 역할을 함.
---
# 🌟 Ext JS 이벤트와 컴포넌트 접근🌈

#### 텍스트 필드의 `click` 이벤트와 `el` 사용 이유

Ext JS에서 텍스트 필드(`textfield`)에 직접 `click` 이벤트를 추가하려 할 때, 일반적인 방식으로는 이벤트가 기대하는 대로 작동하지 않을 수 있음. 이는 `textfield` 자체가 입력을 받는 목적으로 설계되었기 때문에, 기본적으로 클릭 이벤트를 처리하는 방식이 다를 수 있기 때문. 그래서 `textfield`의 클릭 이벤트를 감지하고자 할 때는 `el` 속성을 사용하여 접근.

- **`el`의 역할:**
    - `el`은 Ext JS 컴포넌트의 Element를 가리키며, 컴포넌트의 DOM 요소에 직접 접근할 수 있게 해줌. `el`을 사용하면 컴포넌트를 구성하는 기본 HTML 요소에 대한 이벤트 리스너를 추가할 수 있음.

- **왜 `el`이 필요한가?**
    - `textfield`와 같은 일부 컴포넌트들은 사용자 상호작용을 특정 목적(여기서는 텍스트 입력)으로 제한하도록 설계되어 있음. 이러한 컴포넌트에서 클릭 같은 일반적인 이벤트를 처리하려면, 컴포넌트가 아닌 기본 HTML 요소에 이벤트 리스너를 직접 추가해야 할 필요가 있음. `el` 속성을 사용하면 이러한 접근이 가능.

- **예제 코드 설명:**
    ```javascript
    xtype: 'textfield',
    fieldLabel: '제목1',
    labelAlign: 'right',
    name: 'subject1',
    width: 150,
    listeners: {
        el: {
            click: function() {
                Ext.Msg.alert('확인', '클릭');
            }
        }
    }
    ```
 ####   이 코드는 `textfield`의 기본 DOM 요소에 클릭 이벤트 리스너를 추가. 사용자가 텍스트 필드를 클릭하면, '확인' 메시지가 나타남. 이 방식을 통해 텍스트 필드와 같이 기본적으로 클릭 이벤트를 처리하지 않는 컴포넌트에 대해서도 클릭 이벤트를 정의할 수 있음.

#### 핵심 포인트:
#### `el`을 사용하는 이유는 Ext JS의 고급 컴포넌트가 HTML 요소와는 다른 방식으로 이벤트를 처리하기 때문. `el`을 통해 컴포넌트의 기본 HTML 요소에 직접 접근하여, 표준 HTML 요소에서 기대하는 이벤트 처리 방식을 구현할 수 있음.
---


- **이벤트 처리 방식:**
    버튼 컴포넌트에 클릭 이벤트 리스너를 추가하는 방법입니다. 사용자가 '조회' 버튼을 클릭하면, 특정 동작을 수행하는 함수가 호출됩니다.

- **코드 예시:**
```javascript
    // 보통 버튼에서 이벤트를 추가하는 방법은 listener 를 정의하여 click 이벤트를 정의
                // 하지만 일반적으로 버튼이나 이런것들은 click 이벤트를 많이사용하기때문에 handler 이벤트를 부여가능 정식은 listener click
                xtype:'button',
                text:'조회',
                listeners:{
                    click:function(){
                    let text1 = this.up('panel').down('[name=subject1]');
                    let text2 = this.up('panel').down('[name=subject2]');
                        // let text1 = this.previousSibling('[name=subject1]');
                        // let text2 = this.previousSibling('[name=subject2]');
                   // let text1 =  Ext.ComponentQuery.query('textfield[name=subject1]')[0];
                   // let text2 =  Ext.ComponentQuery.query('textfield[name=subject2]')[0];
                    text2.setValue(text1.getValue());
```

- **핵심 개념 설명:**
    - `this`: 이벤트 핸들러 내에서 `this`는 현재 이벤트를 발생시킨 컴포넌트, 즉 '조회' 버튼을 참조.
    - `up('panel')`: `this.up('panel')` 메서드는 현재 컴포넌트(버튼)로부터 시작하여 상위 컴포넌트 중 'panel' xtype을 가진 첫 번째 컴포넌트를 찾습니다. 이는 버튼이 포함된 패널을 찾기 위해 사용.
    - `down('[name=subject1]')`: 찾은 패널 컴포넌트에서 `down` 메서드를 사용하여 'name' 속성이 'subject1'인 하위 컴포넌트를 탐색. 이 방식으로 특정 텍스트 필드를 직접 찾을 수 있음.
    - `setValue(text1.getValue())`: `text1` 텍스트 필드의 값을 `text2` 텍스트 필드에 설정합니다. 이를 통해 '제목1' 필드의 입력 값을 '제목2' 필드로 복사하는 동작을 구현.

## 💡  **비전공자를 위한 설명:**
 ####   이 예제에서는 버튼을 클릭했을 때 발생하는 동작을 정의하는 방법을 보여줌. 사용자가 '조회' 버튼을 클릭하면, 첫 번째 텍스트 필드의 내용이 두 번째 텍스트 필드로 복사됨. 이 과정에서 `up`과 `down` 메서드를 사용하여 특정 컴포넌트를 찾는 방법과, 이벤트를 처리하는 함수 내에서 `this` 키워드의 사용법을 이해할 수 있음. 이는 Ext JS에서 컴포넌트 간에 데이터를 전달하거나 상호작용을 구현할 때 유용한 패턴.
---

 ### `previousSibling` 메서드 이해하기

Ext JS에서 `previousSibling` 메서드는 현재 컴포넌트의 직전 형제 컴포넌트를 찾는 데 사용됨. 이 메서드는 특정 컴포넌트를 기준으로 바로 앞에 위치한 형제 컴포넌트에 접근할 때 유용.

## 💡  핵심 개념

- **`previousSibling` 메서드 사용법:**
    ```javascript
    // 예시 코드는 주석 처리
    // let text1 = this.previousSibling('[name=subject1]');
    // let text2 = this.previousSibling('[name=subject2]');
    ```
    이 코드 조각에서 `this.previousSibling('[name=subject1]')`는 현재 컴포넌트(예를 들어, 버튼)로부터 시작하여, 같은 부모를 공유하고 바로 앞에 위치한 `[name=subject1]` 속성을 가진 형제 컴포넌트를 찾음.

- **적용 상황:** 이 방식은 형제 컴포넌트들이 순차적으로 배치된 상황에서, 특정 컴포넌트를 기준으로 앞에 위치한 컴포넌트를 찾고자 할 때 특히 유용.

## 💡  비전공자를 위한 설명

#### 상상해 보자, 당신이 줄을 서 있는데, 바로 앞 사람에게 무언가를 건네주어야 한다고 함. 여기서 당신은 현재 컴포넌트(`this`)이며, 바로 앞 사람은 `previousSibling`에 해당합니다. Ext JS에서는 이와 같은 방식으로 컴포넌트 간의 위치 관계를 정의하여, 특정 컴포넌트와 그 앞에 위치한 컴포넌트 간에 상호작용을 할 수 있음.

## 🚨 사용 시 주의점

#### `previousSibling` 메서드는 구조가 단순하고 예측 가능할 때 가장 잘 작동합니다. 복잡한 UI 구조에서는 예상치 못한 컴포넌트를 찾거나, 원하는 컴포넌트를 찾지 못할 수도 있음. 따라서 사용하기 전에 컴포넌트의 정확한 구조와 관계를 파악하는 것이 중요.
---

### `Ext.ComponentQuery.query` 메서드 사용하기

`Ext.ComponentQuery.query`는 Ext JS에서 제공하는 강력한 도구로, 문서 전체 또는 특정 컴포넌트 범위 내에서 조건에 부합하는 컴포넌트를 찾는 데 사용. 이 메서드는 CSS 선택자와 유사한 문법을 사용하여 컴포넌트를 탐색할 수 있게 해줌.

#### 예제 코드 설명

```javascript
// let text1 = Ext.ComponentQuery.query('textfield[name=subject1]')[0];
// let text2 = Ext.ComponentQuery.query('textfield[name=subject2]')[0];
```

## `Ext.ComponentQuery.query` 메서드 사용 이해

#### `Ext.ComponentQuery.query`는 Ext JS의 중요한 기능 중 하나로, 애플리케이션 전체에서 특정 조건을 만족하는 컴포넌트를 찾는 데 사용됨. 이 메서드를 통해 복잡한 UI 구조 속에서도 원하는 컴포넌트를 쉽게 찾을 수 있음.

#### 핵심 개념

- **선택자 사용:**
    - `Ext.ComponentQuery.query` 메서드는 CSS 선택자와 유사한 문법을 사용하여 컴포넌트를 탐색. 
    - 예: `'textfield[name=subject1]'`은 `name` 속성이 `subject1`인 모든 텍스트 필드를 의미

- **전역 탐색:**
    - 이 메서드는 애플리케이션 전체를 대상으로 탐색을 수행합니다. 따라서 같은 조건을 만족하는 컴포넌트가 여러 개 있을 경우, 이들을 모두 찾아 배열로 반환.

- **인덱스 접근:**
    - 반환된 컴포넌트 목록은 배열 형태이기 때문에, 특정 컴포넌트에 접근하기 위해서는 배열의 인덱스를 사용해야 함.
    - `[0]`은 반환된 배열에서 첫 번째 컴포넌트를 가리키며, 대부분의 경우 원하는 컴포넌트에 접근하기 위해 사용됨.

## 💡 비전공자를 위한 설명

#### 🔍 상상해 보자, 당신이 도서관에서 특정 저자의 책을 찾고 있다. `Ext.ComponentQuery.query`는 그 도서관의 모든 책 중에서 원하는 조건(저자, 제목 등)에 부합하는 책들을 찾아주는 도우미와 같다. 결과는 여러 권의 책일 수 있으며, 그 중에서 당신이 찾고자 하는 특정 책을 선택해야 함.

#### 이 방식은 애플리케이션 내에서 특정 조건을 만족하는 컴포넌트를 효과적으로 찾고자 할 때 매우 유용. 하지만, 전역적으로 탐색을 수행하기 때문에 성능 고려와 정확한 탐색을 위해 사용 조건을 명확히 정의하는 것이 중요. 이러한 방식을 통해 복잡한 UI 구조에서도 필요한 컴포넌트를 효과적으로 찾아낼 수 있음.
---













