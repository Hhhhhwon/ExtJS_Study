# 📚 Ext JS 개발 가이드 목차 🌟

- 🌈 [Ext JS 기본 컴포넌트 가이드](#🌟-ext-js-기본-컴포넌트-가이드-🌈)
    - 📝 [Ext JS 컴포넌트 기본 소개](#🛠-기본-컴포넌트-소개-🎯)
- 📄 [Ext JS 예제 페이지 기본 구조](#📖-ext-js-페이지-기본-구조-📄)
    - 🔍 [Ext JS 애플리케이션의  예제 (index.html) HTML 구조 설명](#📑-ext-js-애플리케이션의-indexhtml-html-구조-설명-🌟)
- 💡[Ext JS 애플리케이션 예제 코드(index.js) 분석](#🌟ext-js-애플리케이션-예제-코드indexjs-분석-📘)
- 🌈[Ext JS 컨테이너와 레이아웃](#🌟-ext-js-컨테이너와-레이아웃-🌈)
- 🌈[Ext JS 이벤트와 컴포넌트 접근](#🌟-ext-js-이벤트와-컴포넌트-접근🌈)
- 🌈[Ext JS 클래스 정의와 상속](#🌟-ext-js-클래스-정의와-상속🌈)
- 🌈[Ext JS MVC 아키텍쳐(Acrhitecture)](#🌈-ext-js-mvc-아키텍쳐-mvc-architecture-🏛️🖥️) 
- 🌈[Ext JS MVC 아키텍쳐(Acrhitecture)2](#🌈-ext-js-mvc-아키텍쳐-mvc-architecture-ii-🏛️-스토어-사용)
- 🌈[Ext JS MVVM 아키텍쳐(Acrhitecture)](#🌈-ext-js-mvvm-아키텍처-architecture-model-view-viewmodel)
- 🌈[Ext JS MVVM 아키텍쳐(Acrhitecture)2](#🌈-ext-js-mvvm-아키텍처-architecture-ii-model-view-viewmodel-스토어-사용)
- 🌈[Ext JS MVC + MVMM](#🌈-mvc--mvvm-아키텍처의-혼합-사용에-대한-이해-🌟)
- [Ext JS MVC + MVMM 2](#🌈-mvc--mvvm-아키텍처의-혼합-사용에-대한-이해-ii-🌟)
- 🌈[Ext JS 서버 연동 AJAX](#🌟-ext-js-서버-연동-extajax-🌈)
- 🌈[Ext JS 서버 연동 Store](#🌈-서버연동-store-사용-🎯)
- 
---

# 🌟 Ext JS 기본 컴포넌트 가이드 🌈

### Ext JS는 방대한 UI 컴포넌트 라이브러리를 제공하며, 이는 개발 과정에서 필수적인 자산. 여기서는 Ext JS에서 제공하는 주요 기본 컴포넌트들을 소개하고, 실습 준비 방법에 대해 안내. 🚀

# 🛠 기본 컴포넌트 소개 🎯

- **Panel (`Ext.panel.Panel`)**: 🖼 다양한 UI 구성 요소를 담을 수 있는 컨테이너. 레이아웃 및 이벤트 관리에 최적화.
- **TextField (`Ext.form.field.Text`)**: 📝 사용자로부터 텍스트 입력을 받는 필드. 비밀번호, 이메일 등 다양한 입력 유형을 처리할 수 있음.
- **DateField (`Ext.form.field.Date`)**: 📅 사용자가 날짜를 선택할 수 있는 달력 기반 필드.
- **ComboBox (`Ext.form.field.ComboBox`)**: 🔽 사용자가 드롭다운 목록에서 선택할 수 있는 필드. 사용자 정의 옵션 목록을 제공합니다.
- **Grid (`Ext.grid.Panel`)**: 📊 데이터를 그리드 형태로 표시합니다. 정렬, 필터링 등 다양한 데이터 관리 기능을 지원.
- **Tree (`Ext.tree.Panel`)**: 🌲 계층적 데이터를 트리 구조로 표시하는 컴포넌트.
- **Button (`Ext.button.Button`)**: 🖱️ 사용자 인터랙션을 위한 버튼을 생성합니다. 클릭 이벤트 처리를 통해 다양한 작업을 수행할 수 있습니다.
- **Window (`Ext.window.Window`)**: 🏠 독립적인 윈도우를 생성합니다. 모달 및 비모달 창으로 활용할 수 있음.

## 📚 컴포넌트 사용을 위한 참고 자료

Ext JS 컴포넌트들은 그 기능이 매우 방대하기 때문에, [Ext JS 공식 문서](https://docs.sencha.com/extjs/7.0.0/classic/Ext.form.field.Date.html)에서 필요한 컴포넌트를 검색하고, 그 사용법을 익히는 것이 좋음. 🕵️‍♂️

## 🌐 실습 준비하기

1. **폴더 생성**: `C:\WorkspaceExtjs`에 `BasicWidgets` 폴더를 만듦. 📁
2. **필수 파일 복사**: `BasicWidgets`에 CSS 파일과 `ext-all-debug.js` 파일을 복사. 📋
3. **실습 폴더 및 파일 생성**: `BasicWidgets` 내에 `BasicComp` 폴더를 만들고, 이 폴더 안에 `index.html`과 `index.js` 파일을 생성. ✨
4. **VSCode로 작업 공간 열기**: VSCodegit add를 실행하여 `BasicWidgets` 폴더를 열고 실습을 준비. 🖥
---

#  📖 Ext JS 페이지 기본 구조 📄

### HTML 문서의 기본 구조와 함께 Ext JS 라이브러리와 CSS를 포함하는 방법에 대해 알아보자.

## 📑 페이지 구조와 핵심 요소

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="../BasicClassicApp-all.css">
    <script language="javascript" src="../ext-all-debug.js"></script>
    <script language="javascript" src="index.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    
</body>
</html>
```
#  📑 Ext JS 애플리케이션의 (index.html) HTML 구조 설명 🌟

앞서 제공된 HTML 템플릿은 Ext JS 애플리케이션 개발의 기본 출발점. 여기서 사용된 Ext JS의 기본 CSS와 JavaScript 파일을 연결하는 방법을 아래와 같이 자세히 설명.

## 🌐 DOCTYPE 선언
- `<!DOCTYPE html>`: HTML5 표준을 준수함을 선언하여, 현대적인 웹 표준에 맞게 Ext JS 애플리케이션을 개발할 수 있도록 하자.

## 🖥 `<html>` 태그
- 페이지의 전체 내용을 감싸는 루트 요소. 모든 HTML 요소는 이 `<html>` 태그 내부에 위치해야 합니다.

## 📚 `<head>` 섹션
- 페이지의 메타 데이터, 외부 리소스 링크, 스크립트 등을 정의하는 섹션.

### 🔤 문자 인코딩 설정
- `<meta charset="UTF-8">`: 페이지의 문자 인코딩을 UTF-8로 설정하여 글로벌 언어 지원을 최적화.

### 📄 문서 제목
- `<title>Document</title>`: 브라우저 탭에서 표시될 문서의 제목을 설정.

### 🎨 CSS 스타일시트 링크
- `<link rel="stylesheet" type="text/css" href="../BasicClassicApp-all.css">`: Ext JS 애플리케이션에 적용될 기본 스타일을 정의한 CSS 파일을 문서에 연결. 이 CSS 파일은 Ext JS 컴포넌트의 스타일을 포함하고 있음.

### 📜 JavaScript 파일
- Ext JS 라이브러리(`ext-all-debug.js`)와 애플리케이션의 메인 JavaScript 파일(`index.js`)을 페이지에 포함시킵니다. `ext-all-debug.js`는 디버깅에 유용한 정보를 제공하는 Ext JS 라이브러리의 버전.

### 🖥️ 반응형 웹 디자인
- `<meta name="viewport" content="width=device-width, initial-scale=1.0">`: 페이지가 다양한 디바이스와 화면 크기에 적절하게 응답하도록 설정.

## 📱 `<body>` 섹션
- 실제 페이지 콘텐츠와 Ext JS로 구성된 UI 컴포넌트를 포함할 부분. 여기에 정의된 JavaScript 코드를 통해 동적인 사용자 인터페이스를 구성하고 Ext JS의 강력한 기능을 활용.

### 이 구조를 이해하고 적용함으로써, Ext JS 애플리케이션 개발을 효율적으로 진행할 수 있으며, Ext JS의 다양한 UI 컴포넌트와 기능을 최대한 활용할 수 있음.
---


# 🌟Ext JS 애플리케이션 예제 코드(index.js) 분석 📘
## Ext.onReady(...) 함수 설명

### 🚀 기능
#### `Ext.onReady(function(){...});`는 Ext JS 프레임워크에서 제공하는 핵심 메서드입니다. 이 메서드는 웹 페이지의 모든 리소스가 로드되고 나서, 즉 문서의 DOM이 완전히 구성된 후에 실행될 JavaScript 코드를 정의하는 데 사용됨. 

### 🔍 상세
- **중요도:** 🌟🌟🌟
- 이 메서드는 애플리케이션의 시작점 역할을 함. 여기서 애플리케이션에 필요한 데이터를 불러오거나, UI 컴포넌트를 초기화하는 등의 작업을 수행할 수 있음.
- Ext JS를 사용한 웹 애플리케이션 개발 시, 페이지 로딩이 완료되고 사용자에게 UI를 제공하기 전에 필요한 모든 초기 설정 작업을 이 곳에서 처리.

### 🎯 사용 예
```javascript
Ext.onReady(function(){
    // DOM이 준비되었으므로, 여기서 UI 컴포넌트를 생성하거나 초기화 작업을 수행할 수 있습니다.
    Ext.create('Ext.Button', {
        text: 'Click me',
        renderTo: Ext.getBody(),
        handler: function() {
            alert('Button clicked!');
        }
    });
});

// 위 예제에서는 Ext.onReady 내부에서 Ext JS의 버튼 컴포넌트를 생성. 버튼이 클릭되면 간단한 알림(alert) 메시지를 보여줌.
```

### 💡 비전공자를 위한 추가 설명
#### 웹 페이지가 사용자에게 보여지기 전에, 페이지의 모든 요소가 제대로 로드되고 준비되었는지 확인하는 단계가 필요함. Ext.onReady(...)는 바로 그런 준비 단계를 안전하게 처리할 수 있는 방법을 제공.
#### 단순히 문서가 로드되기를 기다리는 것 뿐만 아니라, Ext JS 프레임워크와 함께 사용될 다양한 컴포넌트들이 올바르게 작동할 수 있는 환경을 만들어줌.
---

## Ext.panel.Panel (패널 컴포넌트)
- **중요도:** 🌟🌟🌟🌟
- **기능:** Ext JS에서 가장 기본적인 컨테이너 컴포넌트로, 다양한 UI 요소들을 그룹화하고 관리하는 데 사용됩니다. 패널은 텍스트, HTML 콘텐츠, 다른 Ext JS 컴포넌트들을 포함할 수 있으며, 탭, 툴바, 버튼 등의 추가 기능을 통해 상호작용적인 사용자 인터페이스를 구성할 수 있음.

### 🛠 구성 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'My Panel', // 패널의 제목을 설정.
    width: 600, // 패널의 너비를 지정.
    height: 400, // 패널의 높이를 지정.
    renderTo: Ext.getBody() // 패널을  body에 렌더링 // // document.body
    layout: 'fit', // 패널 내부 컴포넌트의 레이아웃을 정의.
    items: [{ // 패널에 포함할 자식 컴포넌트들을 배열로 정의.
        xtype: 'grid', // 예를 들어, 그리드 컴포넌트를 자식으로 포함할 수 있음.
        columns: [...], // 그리드의 컬럼 설정
        store: {...} // 그리드에 데이터를 제공하는 스토어 설정
    }]
});
// 이 예제에서는 기본적인 패널을 생성하고, 그 내부에 그리드 컴포넌트를 자식으로 포함시키는 방법을 보여줌. 패널의 layout을 'fit'으로 설정하면, 내부 컴포넌트는 패널의 전체 영역을 차지하도록 확장됨.
```
## 💡 비전공자를 위한 추가 설명
#### 패널은 웹 페이지 내에서 여러 요소들을 하나의 단위로 묶어서 관리하고자 할 때 유용한 컴포넌트. 예를 들어, 사용자 정보를 입력받는 양식, 상품 목록을 보여주는 테이블 등을 패널 안에 배치하여, 웹 애플리케이션의 구조를 명확하고 깔끔하게 구성할 수 있음.
#### 패널은 그 자체로도 유용하지만, `items` 속성을 통해 다른 컴포넌트들을 포함시켜 더 복잡한 레이아웃을 구성하는 기반으로 사용됩니다. 패널의 `title`, `width`, `height`와 같은 속성을 통해 외관과 크기를 쉽게 조절할 수 있으며, 필요에 따라 추가적인 UI 요소(예: 버튼, 툴바)를 통합할 수 있음.
---

## Ext.create 함수 상세 설명

### 🛠 기능
#### `Ext.create` 함수는 Ext JS 프레임워크에서 UI 컴포넌트나 다른 객체를 동적으로 생성할 때 사용됩니다. 이 메서드를 통해 클래스의 인스턴스를 만들고, 필요한 초기 설정을 적용할 수 있습니다.

### 🔍 상세
- **중요도:** 🌟🌟🌟
- `Ext.create`는 클래스 이름과 객체 설정을 매개변수로 받아, 해당 클래스의 새 인스턴스를 생성. 생성된 인스턴스는 즉시 사용할 수 있으며, Ext JS 애플리케이션 내의 다양한 위치에서 참조.
- 이 메서드는 애플리케이션의 유연성과 확장성을 크게 향상시킴. 개발자는 런타임 시에 필요한 컴포넌트를 생성하고, 조건에 따라 다양한 설정을 적용 가능.

### 🎯 사용 예
```javascript
Ext.create('Ext.form.TextField', {
    fieldLabel: '이름',
    renderTo: Ext.getBody() // document.body
});
// 위 예제는 텍스트 입력 필드를 생성하고, 웹 페이지의 본문에 그 필드를 렌더링. fieldLabel은 입력 필드 옆에 표시될 라벨을 지정.
```

## 💡 비전공자를 위한 추가 설명
#### Ext.create 함수는 Ext JS에서 매우 자주 사용되는 핵심 메서드 중 하나. 웹 페이지에 표시할 버튼, 텍스트 필드, 패널 등 다양한 UI 컴포넌트를 만드는 데 사용됨.
#### 사용자가 인터페이스와 상호작용할 수 있는 요소를 프로그래밍 방식으로 쉽게 추가하고, 그 요소들을 원하는 대로 조절할 수 있게 해줌. 예를 들어, 사용자의 액션에 따라 새로운 입력 필드를 페이지에 추가하거나, 특정 이벤트가 발생했을 때 팝업 창을 표시하는 등의 동작을 구현할 수 있음.
---

## Ext.form.field.Text (텍스트 필드)
- **중요도:** 🌟🌟🌟🌟
- **기능:** 사용자로부터 문자열 입력을 받기 위한 기본적인 입력 필드. 폼 내에서 사용자의 데이터 입력을 받는 데 주로 사용.

### 🛠 구성 예시
```javascript
Ext.create('Ext.form.field.Text', {
    fieldLabel: '이름', // 입력 필드 옆에 표시될 라벨을 설정
    allowBlank: false, // 입력 필드가 비어 있을 수 없음을 나타냄
    maxLength: 50, // 입력 가능한 최대 문자 수를 지정
    renderTo: Ext.getBody() // 텍스트 필드를 문서의 body에 렌더링.
});
// 이 예제에서는 사용자의 이름을 입력받기 위한 텍스트 필드를 생성. fieldLabel을 통해 입력 필드 옆에 '이름'이라는 라벨이 표시되며, allowBlank: false 설정으로 사용자가 반드시 이 필드를 채워야 함을 요구.
```

## 💡 비전공자를 위한 추가 설명
#### 텍스트 필드는 웹 폼에서 가장 자주 사용되는 요소 중 하나. 사용자가 웹사이트에 정보(예: 이름, 이메일 주소, 검색어 등)를 입력할 때 사용.
#### 텍스트 필드는 입력받은 데이터를 서버로 전송하기 전에 사용자 인터페이스에 임시로 저장하는 역할을 함. 예를 들어, 회원 가입 양식에서 사용자의 이름을 입력 받거나, 검색 엔진에서 검색어를 입력 받는 데 사용할 수 있음.
#### `allowBlank`: `false`와 같은 속성을 사용하여 입력 필드의 유효성 검사 규칙을 설정할 수 있음. 이를 통해, 사용자가 올바른 형태의 데이터를 입력하도록 요구할 수 있으며, 필수 입력 사항을 지정할 수도 있음.
#### `maxLength` 속성을 설정함으로써, 입력 필드에 입력할 수 있는 문자의 수를 제한할 수 있음. 이는 사용자가 너무 많은 데이터를 입력하는 것을 방지하고, 데이터 처리 시 발생할 수 있는 문제를 미리 방지하는 데 도움이 됨.
---

## Ext.form.field.Date (날짜 필드)
- **중요도:** 🌟🌟🌟🌟
- **기능:** 사용자로부터 날짜 입력을 받는 필드. 달력 팝업을 제공하여 사용자가 특정 날짜를 쉽게 선택할 수 있음.

### 🛠 구성 예시
```javascript
Ext.create('Ext.form.field.Date', {
    fieldLabel: '생년월일', // 입력 필드 옆에 표시될 라벨
    name: 'birthday', // 폼 데이터를 서버로 전송할 때 사용될 필드의 이름
    allowBlank: false, // 이 필드를 필수 입력 필드로 설정
    maxValue: new Date(), // 선택할 수 있는 최대 날짜를 오늘로 설정
    renderTo: Ext.getBody() // 날짜 필드를 문서의 body에 렌더링
});
// 이 예제에서는 사용자의 생년월일을 입력받기 위한 날짜 필드를 생성. fieldLabel로 '생년월일'이라는 라벨을 설정하고, allowBlank: false를 통해 필수 입력 필드로 지정. maxValue 설정으로 사용자가 오늘 이후의 날짜를 선택할 수 없게 함.
```
## 💡 비전공자를 위한 추가 설명
#### 날짜 필드는 웹 폼에서 사용자에게 특정 날짜를 입력받아야 할 때 사용. 예를 들어, 온라인 예약 시스템에서 예약 날짜를 선택하거나, 개인 정보를 입력할 때 생년월일을 입력하는 경우에 활용됨.
#### 날짜 필드는 달력 팝업을 제공하여, 사용자가 날짜를 직접 입력하는 대신 달력에서 날짜를 선택할 수 있게 함. 이는 사용자가 날짜 형식에 신경 쓰지 않고도 손쉽게 날짜를 입력할 수 있게 해줌.
#### maxValue와 같은 속성을 설정하여 입력 가능한 날짜의 범위를 제한할 수 있음. 이를 통해, 미래의 날짜나 과거의 특정 시점 이전의 날짜를 선택하지 못하게 할 수 있음.
#### 날짜 필드를 사용하면 폼 데이터의 유효성 검사를 손쉽게 할 수 있으며, 사용자에게 더 나은 입력 경험을 제공할 수 있음.
---



## Ext JS의 `items` 배열과 `xtype` 속성

### 📦 items 배열
- **중요도:** 🌟🌟🌟
- **기능:** `items` 속성은 Ext JS 컨테이너 컴포넌트(예: 패널) 내에 포함될 자식 컴포넌트들의 배열을 정의합니다. 이 배열에 포함된 각 컴포넌트는 컨테이너 내에 순차적으로 배치.
- **설명:** 컨테이너 컴포넌트는 여러 개의 자식 컴포넌트를 그룹화하고 관리할 수 있음. `items` 배열을 사용하여 이러한 자식 컴포넌트들을 정의하고, 컨테이너에 추가. 각 아이템은 컴포넌트의 구체적인 타입(`xtype`), 설정, 레이아웃 등을 포함할 수 있음.

### 🛠 xtype 속성
- **중요도:** 🌟🌟🌟
- **기능:** `xtype` 속성은 컴포넌트의 별칭(alias)을 지정하여, 해당 타입의 컴포넌트를 생성할 때 사용됨. `xtype`을 사용함으로써, 개발자는 클래스 이름을 명시하지 않고도 컴포넌트를 간편하게 지정할 수 있음.
- **설명:** `xtype`은 Ext JS 프레임워크 내에서 사전 정의된 컴포넌트 타입을 참조하기 위한 간단한 방법입니다. 예를 들어, `'textfield'`, `'button'`, `'grid'` 등이 있고, 컨테이너의 `items` 배열 내에서 `xtype`을 사용하여 필요한 컴포넌트를 쉽게 추가할 수 있음.

### 🎯 사용 예
```javascript
{
    xtype: 'panel',
    items: [
        {
            xtype: 'textfield',
            fieldLabel: '이름'
        },
        {
            xtype: 'datefield',
            fieldLabel: '날짜'
        },
        {
            xtype: 'button',
            text: '확인'
        }
    ]
}
// 위 예제는 xtype을 사용하여 텍스트 필드, 날짜 필드, 버튼을 포함하는 패널을 정의. 이 방식을 통해 각 컴포넌트의 타입을 간단하게 지정하고, 필요한 설정을 적용할 수 있음.
```
## 💡 비전공자를 위한 추가 설명
#### `items` 배열과 `xtype` 속성을 활용하면, 웹 애플리케이션의 인터페이스를 구성하는 여러 컴포넌트를 쉽게 조합하고 구성할 수 있음. 이는 마치 레고 블록을 조립하듯, 필요한 UI 요소들을 선택하고, 조합하여 사용자에게 제공하는 페이지를 만드는 과정과 유사.
---

## Ext JS에서의 `handler` 함수

### 🎯 기능
- **중요도:** 🌟🌟🌟
- `handler` 함수는 Ext JS의 이벤트 핸들러로 사용됨. 주로 버튼 클릭과 같은 사용자 액션에 반응하여 특정 코드를 실행하기 위해 정의.

### 🔍 상세
- `handler` 속성은 컴포넌트(대부분 버튼)에 지정되며, 해당 컴포넌트가 클릭되었을 때 실행할 JavaScript 함수를 정의합니다. 이 함수 내에서는 다양한 로직을 구현할 수 있으며, 예를 들어 사용자에게 메시지를 표시하거나, 다른 뷰로의 네비게이션, 데이터의 처리 등의 작업을 수행할 수 있음.

### 📝 사용 예
```javascript
{
    xtype: 'button',
    text: '클릭',
    handler: function() {
        Ext.Msg.alert('알림', '버튼이 클릭되었습니다!');
    }
}
// 위 예제에서는 버튼 컴포넌트를 정의하고, 해당 버튼이 클릭될 때 간단한 알림 메시지를 보여주는 handler 함수를 구현.
```

## 💡 비전공자를 위한 추가 설명
#### 웹 페이지에서 버튼과 같은 요소를 클릭했을 때 특정 행동을 하게 만들고 싶다면, 그 행동을 정의하는 함수를 만들어야 합니다. handler 함수는 바로 그런 역할을 하는 Ext JS의 방법 중 하나. 쉽게 말해, `handler`는 "이 버튼을 누르면 이 일을 해라"라고 컴퓨터에게 지시하는 역할을 함.
#### 이러한 방식으로 handler를 사용하면, 사용자의 입력에 따라 다양한 반응을 쉽게 프로그래밍할 수 있습니다. 이는 웹 애플리케이션을 더 동적이고 상호작용적으로 만드는 데 중요한 기능.
---

## Ext.form.field.ComboBox 예시와 Store 상세 설명

### 📌 ComboBox 컴포넌트
- **기능:** 사용자가 여러 옵션 중 하나를 선택할 수 있는 드롭다운 목록을 제공.
- **중요도:** 🌟🌟🌟

### 🛠 구성 예시
```javascript
{
    xtype: 'combobox', // 컴포넌트 타입 지정
    fieldLabel: '선택', // 라벨 표시
    labelWidth: 60, // 라벨 너비 설정
    width: 200, // 컴포넌트 전체 너비 설정
    valueField: 'value', // 선택된 항목의 '실제 값'을 나타내는 필드
    displayField: 'display', // 사용자에게 보여지는 '텍스트'를 나타내는 필드
    store: { // 콤보 박스의 데이터를 제공하는 스토어 설정
        fields: ['value', 'display'], // 스토어에 포함될 데이터 모델의 필드 정의
        data: [ // 실제 데이터 목록
            { value: '1', display: '홍길동' },
            { value: '2', display: '임꺽정' },
            { value: '3', display: '유관순' },
            { value: '4', display: '이순신' }
        ]
    }
}
```

## 💡 Store 상세 설명
역할: `store`는 `Ext JS`에서 데이터 컬렉션을 관리하는 컴포넌트. `ComboBox`와 같은 데이터 기반 `UI` 컴포넌트에 데이터를 공급하는 역할을 함.
`fields`: 스토어에서 사용할 데이터 모델의 필드를 정의합니다. 여기서는 각 데이터 항목이 `value`와 `display`라는 두 필드를 갖도록 설정. `value`는 데이터의 실제 값을, display는 사용자에게 보여질 문자열을 나타냄.
`data`: 스토어의 실제 데이터 항목을 배열로 정의합니다. 각 객체는 `fields`에 정의된 필드에 해당하는 값을 갖습니다. 이 데이터는 ComboBox에서 사용자에게 보여질 선택 가능한 옵션들.
## 💡 비전공자를 위한 추가 설명
`store`를 이해하기 쉽게 말하자면, 콤보 박스나 리스트와 같이 여러 데이터를 보여주는 `UI` 컴포넌트에 "무엇을 보여줄지"를 정의하는 데이터의 집합.
예를 들어, 쇼핑몰의 드롭다운 메뉴에서 상품 카테고리를 선택하는 경우, 각 카테고리의 이름`(display`)과 그에 해당하는 고유 번호(`value`)를 `store`에 정의하여 관리할 수 있음. 사용자는 이름을 보고 선택하지만, 시스템은 고유 번호로 해당 카테고리를 식별.
---

## Ext.grid.Panel (그리드 컴포넌트)
- **중요도:** 🌟🌟🌟
- **기능:** 복수의 데이터를 테이블 형태로 보여주는 컴포넌트입니다. 데이터를 구조화된 형태로 표시하고자 할 때 사용됨.

### 🛠 구성 예시
```javascript
{
    xtype: 'grid', // 그리드 컴포넌트의 xtype을 지정.
    width: 300, // 그리드의 너비를 설정.
    height: 300, // 그리드의 높이를 설정.
    store: { // 그리드에 표시될 데이터를 관리하는 스토어를 정의.
        fields: ['value', 'display'], // 스토어에서 관리될 데이터의 필드를 정의.
        data: [ // 스토어의 실제 데이터 항목들을 배열로 정의.
            { value: '1', display: '홍길동' },
            { value: '2', display: '임꺽정' },
            { value: '3', display: '유관순' },
            { value: '4', display: '이순신' },
            { value: '5', display: '강감찬' }
        ]
    },
    columns: [ // 그리드에 표시될 컬럼들을 정의.
        {
            text: '값', // 컬럼의 헤더에 표시될 텍스트.
            dataIndex: 'value', // 이 컬럼에서 표시될 데이터의 필드명.
            width: 100 // 컬럼의 너비를 설정.
        },
        {
            text: '보여주는항목', // 두 번째 컬럼의 헤더 텍스트.
            dataIndex: 'display', // 이 컬럼에서 표시될 데이터의 필드명.
            flex: 1 // 이 컬럼이 남은 공간을 모두 차지.
        }
    ]
}
// 이 예제에서는 각 사람의 고유 번호(value)와 이름(display)을 데이터로 사용하고 있음. 그리드는 이 데이터를 구조화하여 테이블 형태로 보여줌.
```
## 💡 비전공자를 위한 추가 설명
#### 그리드는 흔히 엑셀과 같은 스프레드시트를 떠올리게 하는 데이터 표시 방법입니다. 각 행은 데이터의 한 항목을 나타내며, 각 열은 그 데이터의 속성(예: 이름, 이메일 등)을 나타냅니다.

#### `store`는 그리드가 데이터를 어디서 가져올지, 그리고 어떤 데이터를 가져올지 정의하는 곳. `fields`에서는 데이터의 구조를 정의하고, `data`에서는 실제 표시될 데이터를 제공.
#### `columns`에서는 그리드의 열을 어떻게 구성할지 정의. text는 열의 제목을, dataIndex는 그 열이 어떤 데이터를 표시할지를 결정. flex: 1은 해당 열이 남은 가용 공간을 모두 차지하도록 함, 즉 유동적으로 크기가 조정됨.
---

## Ext.tree.Panel (트리 패널 컴포넌트)
- **중요도:** 🌟🌟🌟
- **기능:** 계층적 데이터를 트리 구조로 보여주는 컴포넌트. 각 항목은 노드라고 하며, 부모-자식 관계를 가질 수 있음.

### 🛠 구성 예시
```javascript
{
    xtype: 'treepanel', // 트리 패널 컴포넌트의 xtype을 지정.
    width: 300, // 트리 패널의 너비를 설정.
    height: 300, // 트리 패널의 높이를 설정.
    store: { // 트리 패널에 표시될 데이터를 관리하는 스토어를 정의.
        root: { // 스토어의 루트 노드를 정의합.
            expanded: true, // 루트 노드가 처음부터 확장(열림) 상태인지를 결정.
            children: [ // 루트 노드의 자식 노드들을 정의.
                {text: '일', leaf: true}, // 'leaf: true'는 더 이상 자식이 없는 최종 노드임을 의미.
                {text: '이', leaf: true}, // 각 노드는 'text' 속성으로 라벨을 가짐.
                {
                    text: '삼', leaf: false, // 'leaf: false'는 이 노드가 자식 노드를 가질 수 있음을 의미합.
                    children: [ // '삼' 노드의 자식 노드들을 정의.
                        {text: '삼-일', leaf: true},
                        {text: '삼-이', leaf: true}
                    ]
                }
            ]
        }
    },
    rootVisible: false, // 루트 노드 자체를 트리 패널에 표시할지 결정. 'false'는 루트 노드를 숨김.
}
```
## 💡 비전공자를 위한 추가 설명
#### 트리 패널은 파일 시스템 탐색기나 조직도와 같은 계층적 구조를 시각적으로 표현할 때 사용. 각 항목(노드)은 다른 항목의 부모 또는 자식이 될 수 있으며, 이를 통해 계층 구조를 나타냄.
#### 예를 들어, '삼'이라는 항목 아래에 '삼-일'과 '삼-이'라는 자식 항목이 있을 때, 이들은 트리 구조에서 '삼'의 자식 노드로 표시됨. 사용자는 '삼' 항목을 클릭하여 자식 항목들을 보거나 숨길 수 있음.
#### `rootVisible: false` 설정은 트리의 최상위 항목을 숨기고, 그 자식 항목들만을 표시하고자 할 때 유용. 이는 사용자에게 보여질 필요가 없는 최상위 레벨의 정보를 숨기기 위해 사용됨.
---

## Ext.window.Window (윈도우 컴포넌트)
- **중요도:** 🌟🌟🌟🌟
- **기능:** 독립적인 윈도우 형태의 UI를 생성하여, 다양한 내용을 팝업 형식으로 사용자에게 보여주는 컴포넌트.

### 🛠 구성 예시
```javascript
let window = Ext.create('Ext.window.Window', {
    title: '윈도우', // 윈도우의 제목
    width: 400, // 윈도우의 너비
    height: 300, // 윈도우의 높이
    items: [{ // 윈도우 내부에 배치될 컴포넌트들
        xtype: 'textfield', // 텍스트 필드 컴포넌트
        fieldLabel: '텍스트' // 텍스트 필드의 라벨
    }]
});
window.show(); // 윈도우를 화면에 표시

// 이 예제에서는 Ext.window.Window를 사용하여 기본 설정(제목, 크기, 내부 컴포넌트)이 적용된 윈도우를 생성하고, .show() 메서드를 호출하여 화면에 표시.
```

## 💡 윈도우 컴포넌트 상세 설명
#### 윈도우 크기와 위치: 윈도우의 `width`와 `height` 속성으로 크기를 지정할 수 있습니다. 또한, `x`와 `y` 속성을 통해 화면 내에서의 위치를 정할 수도 있음.
#### 내부 컴포넌트: `items` 배열을 사용하여 윈도우 내부에 다양한 컴포넌트(예: 텍스트 필드, 버튼, 그리드 등)를 배치할 수 있음. 각 컴포넌트는 `xtype` 속성을 통해 지정됨.
#### 모달 윈도우: `modal` 속성을 `true`로 설정하면, 윈도우가 활성화되어 있는 동안 기타 `UI` 요소와의 상호작용을 차단할 수 있음. 이는 사용자의 주의를 특정 작업에 집중시키고자 할 때 유용.
#### 닫기 및 최소화/최대화: 윈도우는 사용자가 직접 닫거나 최소화/최대화할 수 있는 컨트롤을 제공. 이는 윈도우의 상단 툴바에 기본적으로 포함되어 있음.
## 💡 비전공자를 위한 추가 설명
#### `Ext.window.Window`는 웹 애플리케이션에서 별도의 팝업 창을 생성할 때 사용되는 컴포넌트. 예를 들어, 사용자에게 폼을 채우도록 요청하거나, 중요한 정보를 알림 형식으로 보여주고자 할 때 이 컴포넌트를 활용할 수 있음.
#### 윈도우 내부에는 사용자와의 상호작용을 위한 다양한 요소를 배치할 수 있으며, 이를 통해 동적이고 상호작용적인 사용자 경험을 제공할 수 있음.
---
# 🌟 Ext JS 컨테이너와 레이아웃 🌈

## Layout: 'absolute' (절대적 레이아웃)

- **중요도:** 🌟🌟🌟
- **기능:** 컴포넌트의 위치를 절대 좌표로 지정하여, 컨테이너 내에서 정확한 위치에 배치할 수 있는 레이아웃.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    width: 500,
    height: 400,
    layout: 'absolute', // 절대적 레이아웃을 사용.
    items: [
        {
            xtype: 'textfield',
            fieldLabel: '이름',
            x: 50, // 패널의 왼쪽 가장자리로부터 50픽셀 떨어진 위치에 배치.
            y: 50, // 패널의 상단 가장자리로부터 50픽셀 떨어진 위치에 배치.
            width: 200
        },
        {
            xtype: 'button',
            text: '버튼',
            x: 50, // 동일한 x 좌표에 버튼을 배치하여 텍스트 필드 바로 아래에 위치.
            y: 100, // 텍스트 필드보다 50픽셀 아래에 위치.
            width: 100
        }
    ],
    renderTo: Ext.getBody()
});
// 이 예제에서는 절대적 레이아웃을 사용하여 패널 내의 텍스트 필드와 버튼을 정확한 위치에 배치. 각 컴포넌트는 x와 y 속성을 통해 좌표를 지정.
```
## 💡 비전공자를 위한 추가 설명
#### `absolute` 레이아웃은 웹 페이지 디자인에서 각 요소를 픽셀 단위로 정확히 제어하고자 할 때 유용합니다. 이를 통해, 디자이너는 컴포넌트를 원하는 정확한 위치에 배치할 수 있음.
### 하지만, `absolute` 레이아웃을 사용할 때는 반응형 디자인에 유의. 고정된 위치에 배치된 컴포넌트들은 화면 크기가 변할 때 자동으로 위치가 조정되지 않기 때문에, 다양한 디스플레이 환경에서의 호환성을 고려한 추가적인 처리가 필요할 수 있음.
#### 절대적 레이아웃은 복잡한 레이아웃을 구현해야 하거나, 특정 요소를 다른 요소와 겹치게 하려는 경우와 같이, 특별한 레이아웃 요구사항이 있을 때 선택적으로 사용됨.
---

## Layout: 'fit' (화면 채우기 레이아웃)

- **중요도:** 🌟🌟🌟🌟
- **기능:** 한 개의 자식 컴포넌트만을 포함하며, 해당 자식 컴포넌트를 컨테이너의 전체 크기로 확장하여 화면을 꽉 채우게 하는 레이아웃.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'Fit Layout Panel',
    width: 300,
    height: 150,
    layout: 'fit', // 'fit' 레이아웃을 사용.
    items: [
        {
            xtype: 'panel', // 내부 패널
            html: '내부 컨텐츠는 이 패널을 꽉 채움.'
        }
    ],
    renderTo: Ext.getBody()
});
// 위 예제에서는 외부 패널이 fit 레이아웃을 사용하여 내부에 단 하나의 패널을 포함하고 있고. 내부 패널은 외부 패널의 전체 크기로 자동 조정되어, 화면을 꽉 채우게 됨.
```

## 💡 비전공자를 위한 추가 설명
#### `fit` 레이아웃은 단순하지만 강력한 레이아웃 방식. 주로 전체 화면의 콘텐츠를 표시하거나, 어플리케이션의 메인 뷰를 구성할 때 사용.
#### 예를 들어, 어플리케이션에 메인 콘텐츠 영역이 하나만 있고, 이 영역이 화면 전체를 차지해야 할 때 `fit` 레이아웃이 유용하게 사용될 수 있음.
#### `fit` 레이아웃을 사용하는 컨테이너는 한 번에 하나의 컴포넌트만을 보여줄 수 있습니다. 만약 여러 개의 컴포넌트를 동시에 표시하려면 다른 레이아웃을 고려해야 함.
#### 이 레이아웃은 특히 반응형 디자인에서 유리. 컨테이너의 크기가 변하더라도, 내부 컴포넌트는 항상 컨테이너를 꽉 채우도록 자동으로 크기가 조정되기 때문.
---

## Layout: 'anchor' (앵커 레이아웃)

- **중요도:** 🌟🌟🌟
- **기능:** 컴포넌트들을 상대적인 크기로 순서대로 배치할 수 있게 해주는 레이아웃. 각 컴포넌트는 컨테이너의 상단에서부터 순차적으로 붙어서 배치되며, 개별 컴포넌트의 크기는 퍼센트 또는 고정 값으로 지정할 수 있음.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'Anchor Layout Panel',
    width: 500,
    height: 400,
    layout: 'anchor', // 'anchor' 레이아웃을 사용.
    items: [
        {
            xtype: 'textfield',
            fieldLabel: '이름',
            anchor: '100%' // 컨테이너의 너비를 100% 차지하도록 설정.
        },
        {
            xtype: 'textfield',
            fieldLabel: '이메일',
            anchor: '-10' // 컨테이너 너비에서 10픽셀을 제외한 나머지를 차지하도록 설정.
        }
    ],
    renderTo: Ext.getBody()
});
// 위 예제에서는 anchor 레이아웃을 사용하여 두 개의 텍스트 필드를 패널에 추가. 첫 번째 텍스트 필드는 패널의 전체 너비를 차지하도록 설정되어 있으며, 두 번째 텍스트 필드는 패널의 너비에서 10픽셀을 제외한 나머지 너비를 차지하도록 설정되어 있음.
```

## 💡 비전공자를 위한 추가 설명
#### `anchor` 레이아웃은 웹 페이지의 폼 레이아웃을 구성할 때 특히 유용. 이 레이아웃을 사용하면, 폼 필드의 너비를 폼 컨테이너에 따라 유연하게 조정할 수 있어, 다양한 화면 크기에 적응하는 반응형 디자인을 구현하기 쉬움.
#### `anchor` 속성을 사용해 각 컴포넌트의 크기를 퍼센트 값(예: `'100%`)으로 설정하면, 해당 컴포넌트는 부모 컨테이너의 너비에 상대적으로 크기를 조정. 고정 픽셀 값(예: '-10')을 사용하면, 부모 컨테이너 너비에서 해당 픽셀만큼 뺀 나머지 너비를 차지하게 됨.
#### 이런 방식으로 `anchor` 레이아웃을 활용하면, 폼 필드들이 컨테이너의 크기 변화에 따라 동적으로 크기가 조정되어, 사용자에게 일관된 사용 경험을 제공할 수 있음.
---

## Layout: 'column' (컬럼 레이아웃)

- **중요도:** 🌟🌟🌟🌟
- **기능:** 컨테이너 내의 컴포넌트들을 여러 컬럼으로 나누어 배치할 수 있게 해주는 레이아웃. `columnWidth` 속성을 사용하여 각 컴포넌트가 차지할 컨테이너의 상대적인 너비 비율을 지정할 수 있음.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'Column Layout Panel',
    width: 500,
    height: 200,
    layout: 'column', // 'column' 레이아웃을 사용.
    items: [
        {
            xtype: 'panel',
            title: '컬럼 1',
            columnWidth: 0.5, // 전체 컨테이너 너비의 50%를 차지.
            html: '절반의 너비를 가진 첫 번째 컬럼'
        },
        {
            xtype: 'panel',
            title: '컬럼 2',
            columnWidth: 0.5, // 전체 컨테이너 너비의 나머지 50%를 차지.
            html: '절반의 너비를 가진 두 번째 컬럼'
        }
    ],
    renderTo: Ext.getBody()
});
// 위 예제에서는 column 레이아웃을 사용하여 두 개의 패널을 각각 전체 컨테이너 너비의 50%씩 차지하도록 배치. 각 패널은 columnWidth 속성을 통해 상대적 너비 비율을 지정받음.
```

## 💡 비전공자를 위한 추가 설명
#### 컬럼 레이아웃은 웹 페이지를 여러 세로열로 나누어 정보를 구조화하고 싶을 때 유용한 레이아웃 방식. 예를 들어, 메인 콘텐츠와 사이드바, 또는 여러 개의 카드 형태의 정보를 나란히 표시할 때 사용할 수 있음.
#### `columnWidth` 속성은 각 컴포넌트가 컨테이너의 너비 중 어느 정도 비율을 차지할지 결정. 이는 전체 레이아웃이 유동적으로 조정되어야 하는 반응형 디자인에 매우 유용.
#### 컬럼 레이아웃을 사용하면, 화면 크기가 변하더라도 각 컴포넌트의 상대적인 크기 비율은 유지됨. 이를 통해 다양한 화면 크기에서도 일관된 사용자 경험을 제공할 수 있음.
---

## Layout: 'table' (테이블 레이아웃)

- **중요도:** 🌟🌟🌟🌟
- **기능:** 컨테이너 내의 컴포넌트들을 HTML 테이블과 유사한 형태로 배치할 수 있게 해주는 레이아웃. 테이블 레이아웃을 사용하면, 컴포넌트들을 행과 열로 정렬하여 복잡한 레이아웃을 쉽게 구성할 수 있음.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'Table Layout Panel',
    width: 400,
    height: 200,
    layout: {
        type: 'table', // 테이블 레이아웃 타입을 설정.
        columns: 3 // 컴포넌트들을 3열로 배치.
    },
    items: [
        {
            xtype: 'panel',
            html: 'Cell 1',
            colspan: 2 // 이 컴포넌트가 2개 열의 공간을 차지.
        },
        {
            xtype: 'panel',
            html: 'Cell 2'
            // 기본적으로 1열을 차지.
        },
        {
            xtype: 'panel',
            html: 'Cell 3'
        },
        {
            xtype: 'panel',
            html: 'Cell 4',
            colspan: 3 // 이 컴포넌트가 3개 열의 공간을 차지.
        }
    ],
    renderTo: Ext.getBody()
});
// 위 예제에서는 type: 'table'을 설정하여 테이블 레이아웃을 사용하고, columns: 3으로 총 3열로 구성된 테이블 형태를 만듦. colspan 속성을 사용하여 특정 컴포넌트가 차지할 열의 수를 지정할 수 있음.
```

## 💡 비전공자를 위한 추가 설명
#### 테이블 레이아웃은 웹 페이지에서 데이터를 표 형식으로 보여주거나, 여러 항목을 균일하게 정렬할 때 자주 사용됨. HTML에서 <table> 태그를 사용하는 것과 유사하게, Ext JS에서는 type: 'table' 레이아웃으로 이를 구현할 수 있음.
#### `columns` 속성을 통해 컨테이너를 몇 열로 나눌지 지정할 수 있으며, 각 컴포넌트는 하나 이상의 열을 차지할 수 있음. 이때 `colspan` 속성을 사용하여, 하나의 컴포넌트가 여러 열에 걸쳐 배치되도록 할 수 있음.
#### 테이블 레이아웃을 사용함으로써, 복잡한 구조의 UI를 효과적으로 구성하고, 다양한 정보를 사용자에게 직관적으로 표현할 수 있음. 특히, 폼 필드, 정보 패널, 버튼 등 다양한 컴포넌트를 체계적으로 배열할 때 유용.
---

## Layout: 'card' (카드 레이아웃)

- **중요도:** 🌟🌟🌟🌟🌟
- **기능:** 여러 컴포넌트를 같은 영역에 배치하고, 한 번에 하나의 컴포넌트만을 보여주는 레이아웃. 사용자가 네비게이션을 통해 다른 컴포넌트를 전환할 수 있으며, 이를 통해 멀티 스텝 폼, 탭 인터페이스, 마법사 형태의 UI 등을 구현할 수 있음.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'Card Layout Panel',
    width: 300,
    height: 200,
    layout: 'card', // 카드 레이아웃을 사용합니다.
    items: [
        {
            xtype: 'panel',
            title: '첫 번째 카드',
            html: '첫 번째 컨텐츠 영역.'
        },
        {
            xtype: 'panel',
            title: '두 번째 카드',
            html: '두 번째 컨텐츠 영역.'
        }
    ],
    renderTo: Ext.getBody()
});
// 이 예제에서는 card 레이아웃을 사용하여 두 개의 패널(카드)을 생성. 각 카드는 독립된 컨텐츠를 포함하며, 한 번에 하나의 카드만 사용자에게 보여짐.
```

## 💡 비전공자를 위한 추가 설명
#### `card` 레이아웃은 여러 `"페이지"` 또는 `"단계"`를 하나의 컨테이너 안에서 관리할 때 매우 유용. 각 카드는 서로 다른 뷰를 나타내며, 사용자는 주어진 인터페이스를 통해 각 뷰 사이를 전환할 수 있음.
#### 예를 들어, 사용자가 설문조사를 진행하는 경우, 각 질문이 별도의 카드로 표시될 수 있으며, 사용자는 `"다음"` 버튼을 클릭하여 다음 질문으로 이동할 수 있음. 이렇게 하면, 복잡한 정보를 단계별로 나누어서 보여줄 수 있으며, 사용자 경험을 개선할 수 있음.
#### `card` 레이아웃을 사용하는 컨테이너는 내부의 카드들을 자동으로 숨기거나 보여주는 역할을 함. 개발자는 컴포넌트 간의 전환 로직(예: 버튼 클릭 시 다음 카드로 이동)을 구현하여, 사용자가 각 카드를 탐색할 수 있도록 해야 함.
---

## Layout: 'accordion' (아코디언 레이아웃)

- **중요도:** 🌟🌟🌟🌟
- **기능:** 여러 패널을 세로로 나열하고, 각 패널을 확장하거나 축소하여 내용을 보여주는 레이아웃. 아코디언 레이아웃은 한 번에 하나의 패널만 확장되도록 제한되며, 사용자가 다른 패널을 확장하면 이전에 확장된 패널은 자동으로 축소됨.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'Accordion Layout Panel',
    width: 300,
    height: 400,
    layout: {
        type: 'accordion',
        titleCollapse: true, // 패널 제목을 클릭하면 해당 패널이 확장/축소.
        animate: true, // 확장/축소 시 애니메이션 효과를 적용.
        activeOnTop: true // 활성화된 패널을 아코디언의 최상단으로 이동.
    },
    items: [
        {
            xtype: 'panel',
            title: '패널 1',
            html: '패널 1의 내용...'
        },
        {
            xtype: 'panel',
            title: '패널 2',
            html: '패널 2의 내용...'
        },
        {
            xtype: 'panel',
            title: '패널 3',
            html: '패널 3의 내용...'
        }
    ],
    renderTo: Ext.getBody()
});
/// 이 예제에서는 accordion 레이아웃을 사용하여 세 개의 패널을 포함하는 상위 패널을 생성. 각 패널은 제목을 클릭하여 확장/축소할 수 있으며, 한 번에 하나의 패널만 활성화되어 내용을 표시.
```
## 💡 비전공자를 위한 추가 설명
#### 아코디언 레이아웃은 정보를 카테고리별로 구분하여 효율적으로 표시하고 싶을 때 유용한 방식. 사용자는 관심 있는 카테고리의 패널만을 확장하여 내용을 볼 수 있으며, 화면 공간을 절약할 수 있음.
#### `titleCollapse` 속성을 `true`로 설정하면 패널의 제목 부분을 클릭했을 때 해당 패널이 확장/축소되는 기능이 활성화됨. `animate` 속성으로 확장/축소 시 시각적 효과를 줄 수 있으며, `activeOnTop` 속성은 현재 활성화된 패널을 아코디언의 가장 위로 이동시킴.
#### 아코디언 레이아웃은 FAQ 섹션, 설정 메뉴, 다양한 설정 옵션을 제공하는 양식 등 다양한 사용 사례에서 활용될 수 있음. 사용자는 각 섹션의 제목만 보고 원하는 정보를 쉽게 찾을 수 있으며, 상세 내용은 해당 섹션을 확장함으로써 확인할 수 있음.
---

## Layout: 'hbox' (가로 나열 레이아웃)

- **중요도:** 🌟🌟🌟🌟
- **기능:** 컴포넌트들을 가로로 나열하여 배치하는 레이아웃. 이 레이아웃을 사용하면, 컨테이너의 자식 컴포넌트들을 왼쪽에서 오른쪽으로 순차적으로 정렬할 수 있음.

### 🛠 사용 예시
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'HBox Layout Panel',
    width: 400,
    height: 200,
    layout: {
        type: 'hbox', // 가로 나열 레이아웃을 사용.
        align: 'stretch' // 자식 컴포넌트들을 컨테이너의 높이에 맞춰 늘림.
    },
    items: [
        {
            xtype: 'panel',
            title: '왼쪽 패널',
            flex: 1, // 남은 공간을 기준으로 비율을 결정.
            html: 'flex: 1'
        },
        {
            xtype: 'panel',
            title: '오른쪽 패널',
            flex: 2, // 남은 공간의 두 배 크기로 설정.
            html: 'flex: 2'
        }
    ],
    renderTo: Ext.getBody()
});
// 이 예제에서는 type: 'hbox' 레이아웃을 사용하여 두 개의 패널을 가로로 나열. flex 속성을 사용하여 두 번째 패널이 첫 번째 패널보다 두 배 더 큰 공간을 차지하도록 설정.
```
## 💡 비전공자를 위한 추가 설명
#### `hbox` 레이아웃은 사용자 인터페이스에서 여러 항목을 가로 방향으로 나란히 배열할 때 매우 유용합니다. 예를 들어, 도구 모음, 메뉴 바, 정보 카드 등을 나란히 배치하는 데 적합.
#### `align`: `'stretch'` 설정은 모든 자식 컴포넌트들이 컨테이너의 높이를 균일하게 차지하도록 함. 이는 각 요소가 깔끔하게 정렬되어 시각적 일관성을 유지하게 해줌.
#### `flex` 속성은 컴포넌트가 차지할 공간의 비율을 결정합니다. 이를 통해, 레이아웃 내에서의 공간 분배를 유연하게 조정할 수 있음. 예를 들어, `flex`: 1은 사용 가능한 공간을 다른 `flex` 값을 가진 항목과 비율에 따라 나누어 차지하라는 의미.
---

## Layout: 'vbox' (세로 나열 레이아웃) 세부 설정

- **중요도:** 🌟🌟🌟🌟
- **기능:** 컴포넌트들을 세로 방향으로 나열하여 배치합. `vbox` 레이아웃은 세로 정렬에 특화되어 있으며, 추가적인 속성을 사용해 더욱 세밀한 레이아웃 조정이 가능.

### 🛠 사용 예시와 세부 속성
```javascript
Ext.create('Ext.panel.Panel', {
    title: 'VBox Layout Panel - Advanced',
    width: 400,
    height: 300,
    layout: {
        type: 'vbox', // 레이아웃 타입을 'vbox'로 지정.
        align: 'stretch', // 가로 방향으로 자식 컴포넌트들을 컨테이너 너비에 꽉 차게 늘림.
        pack: 'start' // 세로 방향으로 자식 컴포넌트들을 컨테이너의 시작 부분(위쪽)에서부터 정렬.
    },
    items: [
        {
            xtype: 'panel',
            title: '상단 패널',
            flex: 1, // 사용 가능한 공간에 대해 다른 컴포넌트와 비율로 나누어 차지.
            html: 'flex: 1'
        },
        {
            xtype: 'panel',
            title: '하단 패널',
            flex: 2, // 남은 공간의 두 배 크기로 설정. (상단 패널의 두 배 크기)
            html: 'flex: 2'
        }
    ],
    renderTo: Ext.getBody()
});
```

### `align`: `'stretch'`는 컴포넌트가 가로 방향으로 컨테이너의 전체 너비를 차지하도록 함. 모든 컴포넌트가 동일한 너비를 갖게 됨.
### `pack`: `'start'`는 컴포넌트들이 컨테이너의 상단부터 시작되도록 정렬. 다른 옵션으로는 `center, end, justify`가 있어, 컴포넌트들의 세로 방향 정렬 방식을 결정할 수 있음.
### `flex` 속성을 사용하여 컴포넌트들이 차지할 세로 공간의 비율을 조정할 수 있습니다. 예를 들어, `flex: 1`이 설정된 컴포넌트는 다른 `flex` 값을 가진 컴포넌트와 비교하여 사용 가능한 공간을 비율에 따라 차지하게 됨.

## 💡 비전공자를 위한 추가 설명
#### `vbox` 레이아웃을 사용하면, 웹 애플리케이션의 세로 방향으로 컨텐츠를 효과적으로 배열할 수 있음. 예를 들어, 양식의 필드나 순차적으로 따라야 하는 지침 등을 나열할 때 유용.
#### `align`과 `pack` 속성을 통해, 컴포넌트들의 정확한 위치와 크기를 조절할 수 있어, 원하는 대로 세밀한 레이아웃 디자인이 가능해짐.
#### `flex` 속성은 특히 다양한 크기의 컨텐츠를 다룰 때 유용. 이를 통해 각 컴포넌트의 상대적인 크기를 쉽게 조정할 수 있으며, 화면 공간을 효율적으로 사용할 수 있음.
---

## Layout: 'border' (보더 레이아웃) with Split

- **중요도:** 🌟🌟🌟🌟🌟
- **기능:** 컨테이너를 여러 영역(북, 남, 동, 서, 중앙)으로 나누고, 각 영역에 컴포넌트를 배치합니다. 추가로, `split` 옵션을 활용하여 인접한 영역 사이에 사용자가 크기를 조절할 수 있는 스플리터 바를 제공. 이를 통해, 보더 레이아웃의 유연성이 향상되며, 사용자는 자신의 필요에 맞게 각 영역의 크기를 동적으로 조정할 수 있음.

### 🛠 사용 예시 (스플릿 추가)
```javascript
Ext.create('Ext.panel.Panel', {
    width: 700,
    height: 500,
    layout: 'border', // 보더 레이아웃 사용
    items: [
        {
            region: 'north',
            height: 100,
            title: '북쪽 영역'
        },
        {
            region: 'west',
            width: 150,
            title: '서쪽 영역',
            collapsible: true, // 영역을 접을 수 있게 설정
            split: true // 서쪽 영역과 중앙 영역 사이에 스플리터 바를 추가
        },
        {
            region: 'center',
            title: '중앙 영역',
            html: '주 콘텐츠 영역'
        }
    ],
    renderTo: Ext.getBody()
});

// region 속성을 통해 컴포넌트가 위치할 영역을 지정. border 레이아웃은 center, north, south, east, west의 5가지 영역으로 구분.
// split: true 설정은 지정된 영역에 스플리터 바를 추가. 사용자는 이 바를 드래그하여 영역의 크기를 조절할 수 있으며, 이로 인해 인접 영역의 크기도 자동으로 조정됨.
```

## 💡 비전공자를 위한 추가 설명

### 보더 레이아웃의 이해
보더 레이아웃은 페이지를 `"지역"`으로 구분하여 다양한 기능을 가진 `UI` 요소들을 효율적으로 배치하는 데 사용됨. 이 구조는 다음과 같이 구성:
- **중앙(`center`):** 메인 콘텐츠가 위치. 일반적으로 가장 중요한 정보나 기능을 이 영역에 배치.
- **주변(`north`, `south`, `east`, `west`):** 보조 콘텐츠나 기능적 요소들이 위치합니다. 탐색 메뉴, 도구 모음, 추가 정보 등을 이 영역들에 배치할 수 있음.

이 레이아웃은 특히 대시보드, 웹 애플리케이션, 관리자 인터페이스와 같이 복잡한 정보를 직관적이고 구조화된 방식으로 제공해야 하는 인터페이스에 적합.

### 스플릿 옵션의 중요성
보더 레이아웃에 `split` 옵션을 추가하면, 인접한 영역 사이에 사용자가 크기를 조절할 수 있는 스플리터 바가 생성됨. 이는 웹 애플리케이션의 사용성을 크게 향상시킴:
- **유연성:** 사용자는 자신의 작업 공간을 자유롭게 조정할 수 있음. 특히, 대형 모니터를 사용하거나 여러 작업을 동시에 처리해야 하는 경우 유용.
- **효율적인 공간 활용:** 스플리터 바를 드래그하여 영역의 크기를 조절함으로써, 사용자는 필요에 따라 화면 공간을 보다 효율적으로 활용할 수 있음.
- **동적인 UI 조정:** 마우스를 사용하여 영역의 너비나 높이를 조절할 수 있어, 동적인 UI 조정이 가능합니다. 이를 통해 사용자 경험이 향상됨.

`collapsible` 옵션과 함께 사용하면, 사용자는 영역을 완전히 숨기거나 필요에 따라 다시 표시할 수 있으며, 스플리터 바를 통해 영역의 크기를 세밀하게 조정할 수 있음. 이러한 기능 조합은 정보를 표시하는 대시보드, 복잡한 양식, 에디터 인터페이스 등 다양한 애플리케이션에 적합함.

### 결론
보더 레이아웃과 `split` 옵션의 조합은 사용자에게 다이나믹하고 유연한 인터페이스 조정 기능을 제공함. 복잡한 웹 애플리케이션 구성에서 사용성과 접근성을 향상시키는 중요한 역할을 함.
---
# 🌟 Ext JS 이벤트와 컴포넌트 접근🌈

#### 텍스트 필드의 `click` 이벤트와 `el` 사용 이유

Ext JS에서 텍스트 필드(`textfield`)에 직접 `click` 이벤트를 추가하려 할 때, 일반적인 방식으로는 이벤트가 기대하는 대로 작동하지 않을 수 있음. 이는 `textfield` 자체가 입력을 받는 목적으로 설계되었기 때문에, 기본적으로 클릭 이벤트를 처리하는 방식이 다를 수 있기 때문. 그래서 `textfield`의 클릭 이벤트를 감지하고자 할 때는 `el` 속성을 사용하여 접근.

- **`el`의 역할:**
    - `el`은 Ext JS 컴포넌트의 Element를 가리키며, 컴포넌트의 DOM 요소에 직접 접근할 수 있게 해줌. `el`을 사용하면 컴포넌트를 구성하는 기본 HTML 요소에 대한 이벤트 리스너를 추가할 수 있음.

- **왜 `el`이 필요한가?**
    - `textfield`와 같은 일부 컴포넌트들은 사용자 상호작용을 특정 목적(여기서는 텍스트 입력)으로 제한하도록 설계되어 있음. 이러한 컴포넌트에서 클릭 같은 일반적인 이벤트를 처리하려면, 컴포넌트가 아닌 기본 HTML 요소에 이벤트 리스너를 직접 추가해야 할 필요가 있음. `el` 속성을 사용하면 이러한 접근이 가능.

- **예제 코드 설명:**
    ```javascript
    xtype: 'textfield',
    fieldLabel: '제목1',
    labelAlign: 'right',
    name: 'subject1',
    width: 150,
    listeners: {
        el: {
            click: function() {
                Ext.Msg.alert('확인', '클릭');
            }
        }
    }
    ```
 ####   이 코드는 `textfield`의 기본 DOM 요소에 클릭 이벤트 리스너를 추가. 사용자가 텍스트 필드를 클릭하면, '확인' 메시지가 나타남. 이 방식을 통해 텍스트 필드와 같이 기본적으로 클릭 이벤트를 처리하지 않는 컴포넌트에 대해서도 클릭 이벤트를 정의할 수 있음.

#### 핵심 포인트:
#### `el`을 사용하는 이유는 Ext JS의 고급 컴포넌트가 HTML 요소와는 다른 방식으로 이벤트를 처리하기 때문. `el`을 통해 컴포넌트의 기본 HTML 요소에 직접 접근하여, 표준 HTML 요소에서 기대하는 이벤트 처리 방식을 구현할 수 있음.
---


- **이벤트 처리 방식:**
    버튼 컴포넌트에 클릭 이벤트 리스너를 추가하는 방법입니다. 사용자가 '조회' 버튼을 클릭하면, 특정 동작을 수행하는 함수가 호출됩니다.

- **코드 예시:**
```javascript
    // 보통 버튼에서 이벤트를 추가하는 방법은 listener 를 정의하여 click 이벤트를 정의
                // 하지만 일반적으로 버튼이나 이런것들은 click 이벤트를 많이사용하기때문에 handler 이벤트를 부여가능 정식은 listener click
                xtype:'button',
                text:'조회',
                listeners:{
                    click:function(){
                    let text1 = this.up('panel').down('[name=subject1]');
                    let text2 = this.up('panel').down('[name=subject2]');
                        // let text1 = this.previousSibling('[name=subject1]');
                        // let text2 = this.previousSibling('[name=subject2]');
                   // let text1 =  Ext.ComponentQuery.query('textfield[name=subject1]')[0];
                   // let text2 =  Ext.ComponentQuery.query('textfield[name=subject2]')[0];
                    text2.setValue(text1.getValue());
```

- **핵심 개념 설명:**
    - `this`: 이벤트 핸들러 내에서 `this`는 현재 이벤트를 발생시킨 컴포넌트, 즉 '조회' 버튼을 참조.
    - `up('panel')`: `this.up('panel')` 메서드는 현재 컴포넌트(버튼)로부터 시작하여 상위 컴포넌트 중 'panel' xtype을 가진 첫 번째 컴포넌트를 찾습니다. 이는 버튼이 포함된 패널을 찾기 위해 사용.
    - `down('[name=subject1]')`: 찾은 패널 컴포넌트에서 `down` 메서드를 사용하여 'name' 속성이 'subject1'인 하위 컴포넌트를 탐색. 이 방식으로 특정 텍스트 필드를 직접 찾을 수 있음.
    - `setValue(text1.getValue())`: `text1` 텍스트 필드의 값을 `text2` 텍스트 필드에 설정합니다. 이를 통해 '제목1' 필드의 입력 값을 '제목2' 필드로 복사하는 동작을 구현.

## 💡  **비전공자를 위한 설명:**
 ####   이 예제에서는 버튼을 클릭했을 때 발생하는 동작을 정의하는 방법을 보여줌. 사용자가 '조회' 버튼을 클릭하면, 첫 번째 텍스트 필드의 내용이 두 번째 텍스트 필드로 복사됨. 이 과정에서 `up`과 `down` 메서드를 사용하여 특정 컴포넌트를 찾는 방법과, 이벤트를 처리하는 함수 내에서 `this` 키워드의 사용법을 이해할 수 있음. 이는 Ext JS에서 컴포넌트 간에 데이터를 전달하거나 상호작용을 구현할 때 유용한 패턴.
---

 ### `previousSibling` 메서드 이해하기

Ext JS에서 `previousSibling` 메서드는 현재 컴포넌트의 직전 형제 컴포넌트를 찾는 데 사용됨. 이 메서드는 특정 컴포넌트를 기준으로 바로 앞에 위치한 형제 컴포넌트에 접근할 때 유용.

## 💡  핵심 개념

- **`previousSibling` 메서드 사용법:**
 ```javascript
    // 예시 코드는 주석 처리
    // let text1 = this.previousSibling('[name=subject1]');
    // let text2 = this.previousSibling('[name=subject2]');
```
#### 이 코드 조각에서 `this.previousSibling('[name=subject1]')`는 현재 컴포넌트(예를 들어, 버튼)로부터 시작하여, 같은 부모를 공유하고 바로 앞에 위치한 `[name=subject1]` 속성을 가진 형제 컴포넌트를 찾음.

- **적용 상황:** 이 방식은 형제 컴포넌트들이 순차적으로 배치된 상황에서, 특정 컴포넌트를 기준으로 앞에 위치한 컴포넌트를 찾고자 할 때 특히 유용.

## 💡  비전공자를 위한 설명

#### 상상해 보자, 당신이 줄을 서 있는데, 바로 앞 사람에게 무언가를 건네주어야 한다고 함. 여기서 당신은 현재 컴포넌트(`this`)이며, 바로 앞 사람은 `previousSibling`에 해당합니다. Ext JS에서는 이와 같은 방식으로 컴포넌트 간의 위치 관계를 정의하여, 특정 컴포넌트와 그 앞에 위치한 컴포넌트 간에 상호작용을 할 수 있음.

## 🚨 사용 시 주의점

#### `previousSibling` 메서드는 구조가 단순하고 예측 가능할 때 가장 잘 작동합니다. 복잡한 UI 구조에서는 예상치 못한 컴포넌트를 찾거나, 원하는 컴포넌트를 찾지 못할 수도 있음. 따라서 사용하기 전에 컴포넌트의 정확한 구조와 관계를 파악하는 것이 중요.
---

### `Ext.ComponentQuery.query` 메서드 사용하기

`Ext.ComponentQuery.query`는 Ext JS에서 제공하는 강력한 도구로, 문서 전체 또는 특정 컴포넌트 범위 내에서 조건에 부합하는 컴포넌트를 찾는 데 사용. 이 메서드는 CSS 선택자와 유사한 문법을 사용하여 컴포넌트를 탐색할 수 있게 해줌.

#### 예제 코드 설명

```javascript
// let text1 = Ext.ComponentQuery.query('textfield[name=subject1]')[0];
// let text2 = Ext.ComponentQuery.query('textfield[name=subject2]')[0];
```

## `Ext.ComponentQuery.query` 메서드 사용 이해

#### `Ext.ComponentQuery.query`는 Ext JS의 중요한 기능 중 하나로, 애플리케이션 전체에서 특정 조건을 만족하는 컴포넌트를 찾는 데 사용됨. 이 메서드를 통해 복잡한 UI 구조 속에서도 원하는 컴포넌트를 쉽게 찾을 수 있음.

#### 핵심 개념

- **선택자 사용:**
    - `Ext.ComponentQuery.query` 메서드는 CSS 선택자와 유사한 문법을 사용하여 컴포넌트를 탐색. 
    - 예: `'textfield[name=subject1]'`은 `name` 속성이 `subject1`인 모든 텍스트 필드를 의미

- **전역 탐색:**
    - 이 메서드는 애플리케이션 전체를 대상으로 탐색을 수행합니다. 따라서 같은 조건을 만족하는 컴포넌트가 여러 개 있을 경우, 이들을 모두 찾아 배열로 반환.

- **인덱스 접근:**
    - 반환된 컴포넌트 목록은 배열 형태이기 때문에, 특정 컴포넌트에 접근하기 위해서는 배열의 인덱스를 사용해야 함.
    - `[0]`은 반환된 배열에서 첫 번째 컴포넌트를 가리키며, 대부분의 경우 원하는 컴포넌트에 접근하기 위해 사용됨.

## 💡 비전공자를 위한 설명

#### 🔍 상상해 보자, 당신이 도서관에서 특정 저자의 책을 찾고 있다. `Ext.ComponentQuery.query`는 그 도서관의 모든 책 중에서 원하는 조건(저자, 제목 등)에 부합하는 책들을 찾아주는 도우미와 같다. 결과는 여러 권의 책일 수 있으며, 그 중에서 당신이 찾고자 하는 특정 책을 선택해야 함.

#### 이 방식은 애플리케이션 내에서 특정 조건을 만족하는 컴포넌트를 효과적으로 찾고자 할 때 매우 유용. 하지만, 전역적으로 탐색을 수행하기 때문에 성능 고려와 정확한 탐색을 위해 사용 조건을 명확히 정의하는 것이 중요. 이러한 방식을 통해 복잡한 UI 구조에서도 필요한 컴포넌트를 효과적으로 찾아낼 수 있음.
---

##  🔍 버튼 클릭으로 그리드 데이터 업데이트하기

#### 웹 애플리케이션에서 사용자가 '조회' 버튼을 클릭했을 때, 특정 데이터를 보여주는 그리드(표)를 업데이트하는 기능.

```javascript
// '조회' 버튼 클릭 이벤트 정의
xtype: 'button',
text: '조회',
listeners: {
    click: function() {
        // 현재 버튼이 위치한 패널 내의 그리드 컴포넌트 찾기
        let grid = this.up('panel').down('grid');

        // 그리드의 데이터 저장소에서 모든 데이터 제거
        grid.getStore().removeAll();

        // 데이터 저장소에 새로운 데이터 항목들 추가
        grid.getStore().add({value: '1', display: '값1'});
        grid.getStore().add({value: '1', display: '값2'});
    }
},
```

### 핵심 개념 및 메서드 설명 🔍

- **`getStore()`** 📦: 이 메서드는 그리드와 연결된 데이터 저장소(Store)에 접근. 데이터 저장소는 그리드에 표시되는 모든 데이터를 관리.

- **`removeAll()`** 🗑️: `getStore()`로 얻은 데이터 저장소에서 `removeAll()` 메서드를 호출하면 저장소의 모든 데이터를 지울 수 있음. 즉, 그리드가 비워지게 됨.

- **`add()`** ➕: 그리드의 데이터 저장소에 새로운 데이터를 추가할 때 사용. 여기서는 `{value: '1', display: '값1'}`와 같은 객체 형태로 데이터를 전달해, 그리드에 새로운 행을 추가.

### 추가 메서드 설명 🛠️

- **`up()`** 🔼: 현재 컴포넌트에서 호출되며, 인자로 전달된 선택자에 해당하는 상위 컴포넌트를 찾음. 예를 들어, `this.up('panel')`은 현재 컴포넌트의 상위에 위치한 패널 컴포넌트를 찾음.

- **`down()`** 🔽: `up()`과 반대로, 현재 컴포넌트의 하위에 있는 컴포넌트 중 인자로 전달된 선택자에 해당하는 첫 번째 컴포넌트를 찾음. `this.down('grid')`는 현재 컴포넌트 안에서 찾을 수 있는 첫 번째 그리드 컴포넌트를 찾음.

######  🌟이러한 메서드들을 사용하여, 버튼 클릭에 반응해 동적으로 그리드의 데이터를 조작하고, 웹 페이지를 더 상호작용적으로 만들 수 있음🌟
---

# 🌟 Ext JS 클래스 정의와 상속🌈

### Ext JS는 웹 애플리케이션을 구축하기 위한 풍부한 UI 컴포넌트와 프레임워크를 제공. 중요한 개념 중 하나는 클래스의 정의와 상속.

#### 📘 클래스 정의하기
#### Ext.define 메소드를 사용하여 Ext.panel.Panel이라는 새로운 클래스를 정의하는 방법:
```javascript
Ext.define('Ext.panel.Panel', {
    extend: 'Ext.container.Container', // 상속받을 클래스
    alias: 'widget.panel',             // 이 클래스에 대한 xtype 별칭
    alternateClassName: 'Ext.Panel',   // 클래스에 대한 대체 이름
    requires: [                        // 이 클래스가 의존하는 다른 클래스들
        'Ext.panel.Header',
        'Ext.util.MixedCollection',
        'Ext.toolbar.Toolbar',
        'Ext.fx.Anim',
        'Ext.panel.DD',
        'Ext.XTemplate',
        'Ext.layout.component.Dock',
        'Ext.util.Memento
        ...                            // 기타 필요한 의존성들
    ],
    // 클래스의 속성 및 메서드 정의...
    // Ext.define 메소드를 사용하여 Ext.panel.Panel라는 새로운 클래스를 정의. 이 클래스는 Ext.container.Container를 상속받아 컨테이너의 기능을 확장. alias 속성을 통해 이 클래스를 widget.panel이라는 xtype으로 간편하게 참조.
});
```
### 🚀 `xtype`과 `Ext.create`의 관계
#### `xtype`은 컴포넌트의 별칭으로, `Ext.create` 없이도 컴포넌트를 간단하게 생성할 수 있게 해줌:

```javascript
{
    xtype: 'panel',  // 'widget.panel'의 별칭
    title: '내 패널', // 패널 제목
    width: 600,      // 패널 너비
    height: 400      // 패널 높이
}
```
### 🌟 Ext.application으로 애플리케이션 시작하기
#### 현대적인 Ext JS 애플리케이션 구조에서는 `Ext.onReady` 대신 `Ext.application`을 사용합니다. 이는 `MVC` 또는 `MVVM` 아키텍처를 적용하기에 적합한 방법:

```javascript
Ext.application({
    name: 'MyApp',
    launch: function() {
        // 애플리케이션 시작 시 실행할 코드
        Ext.create('MyApp.view.Main');
    }
});
// Ext.application은 애플리케이션의 이름과 시작 시 수행할 함수를 정의. 여기서는 MyApp.view.Main 뷰를 생성하여 애플리케이션의 메인 화면으로 사용.
```

## 🚀 Ext JS에서 별칭(Alias) 사용하기
#### `Ext JS`에서는 컴포넌트를 더 간단하게 참조할 수 있도록 `alias` 속성을 사용. 특히, UI 컴포넌트에 별칭을 지정할 때는 `widget.` 접두사를 사용하는 것이 일반적.

### 🛠 별칭 지정하기
#### 별칭을 지정하려면, `alias` 속성에 `"widget.별칭"` 형태로 값을 지정. 이렇게 설정하면, 해당 컴포넌트를 xtype을 통해 간단하게 참조할 수 있음.

```javascript
Ext.define('MyApp.view.MyPanel', {
    extend: 'Ext.panel.Panel',
    alias: 'widget.mypanel', // 별칭을 'mypanel'로 지정
    ...
});
```
## 🌈 xtype으로 컴포넌트 참조하기
별칭`(alias)`을 지정한 후에는, `xtype`을 사용하여 해당 컴포넌트를 쉽게 생성할 수 있음. xtype은 별칭의` widget.` 부분을 제외한 값을 사용.

```javascript
{
    xtype: 'mypanel', // 별칭 'widget.mypanel'에 해당하는 컴포넌트 생성
    title: '내 커스텀 패널',
    width: 300,
    height: 200
}
```
## 💡 별칭과 xtype의 중요성
#### 간결성: `alias`와 `xtype`을 사용하면, 긴 클래스 이름을 명시하지 않고도 컴포넌트를 참조하고 생성할 수 있어, 코드가 훨씬 간결해짐.
#### 재사용성: 컴포넌트에 별칭을 지정함으로써, 애플리케이션 전반에 걸쳐 해당 컴포넌트를 쉽게 재사용할 수 있음.
#### 유지보수성: 별칭을 통해 컴포넌트를 참조하면, 컴포넌트의 클래스 이름이 변경되어도 별칭이 유지되는 한 코드의 나머지 부분을 수정할 필요가 없어, 유지보수가 용이해짐.
### 🌟 비전공자를 위한 추가 설명
#### `alias`와 `xtype`을 사용하는 것은 마치 닉네임을 사용해서 친구를 부르는 것과 비슷. 우리가 친구의 정식 이름 대신 닉네임을 사용해서 더 쉽고 빠르게 친구를 부를 수 있는 것처럼, `Ext JS`에서도 `alias`와 `xtype`을 통해 컴포넌트를 더 쉽고 빠르게 사용할 수 있음. 이런 방식으로, 개발자는 복잡한 `UI`를 구성하는 데 필요한 컴포넌트를 더 쉽게 관리하고 재사용할 수 있게 됨.
---
### 📚 Ext.define과 클래스 정의 (예제코드 및 복습)
```javascript
Ext.onReady(function(){
// MyPanel 클래스를 정의. Ext.panel.Panel을 상속받아 기본 패널 기능을 확장.
Ext.define('MyApp.view.MyPanel', {
    extend: 'Ext.panel.Panel',      // Ext.panel.Panel 클래스를 상속.
    alias: 'widget.mypanel',        // 'widget.mypanel'이라는 별칭을 지정.
    bodyStyle: 'background-color:red', // 패널의 바디 스타일을 정의.
    title: '사용자 정의 패널',       // 패널 제목 설정
    width: 400,                     // 패널 너비
    height: 200                     // 패널 높이
});
// ----------------------------------
    Ext.define('클래스명', {
    extend: '상속받을 클래스명',
    alias: 'widget.별칭',
    // 추가 속성 및 메서드 정의...
});
// ----------------------------------

    // MyPanel 인스턴스 생성 및 렌더링
    var panel = Ext.create('Ext.panel.Panel', {
        renderTo: document.body,   // HTML body에 렌더링
        title: '상속받은패널',       // 패널 제목
        width: 600,                // 패널 너비
        height: 600,               // 패널 높이
        items: [{                  // 자식 컴포넌트 추가
            xtype: 'mypanel',      // 위에서 정의한 xtype 사용
            width: 400,
            height: 400,
        }]
    });
});
```

### 💡 Ext.define을 사용하는 이유
- ###### 재사용성: 클래스를 정의함으로써 동일한 구조의 컴포넌트를 여러 곳에서 쉽게 재사용할 수 있음.
- ###### 확장성: 상속 기능을 사용하여 기존 컴포넌트의 기능을 확장하고, 커스텀 동작을 추가할 수 있음.
- ###### 유지보수성: 클래스 단위로 코드를 구성하면, 애플리케이션의 유지보수성이 향상.

### 🚀 Ext.onReady vs Ext.application
#### `Ext.onReady`: 페이지가 전부 로드되고 준비된 후에 실행되는 코드를 정의. 기본적인 `Ext JS` 예제나 작은 스크립트에서 자주 사용. 🛠

#### `Ext.application`: 현대적인 `Ext JS` 애플리케이션에서 사용되며, `MVC` 또는 `MVVM` 아키텍처를 기반으로 한 애플리케이션 구조를 정의. 🏗
---
## 🛠 extend 속성: 클래스 상속 이해하기
#### `Ext JS`에서 `extend` 속성은 클래스 상속의 핵심. 이 속성을 사용하여 기존 클래스의 기능을 확장하고, 새로운 커스텀 클래스를 정의할 수 있음.

### 🌱 기본 사용법:
#### `extend` 속성에는 상속받고자 하는 부모 클래스의 이름이 지정됨. 이를 통해 부모 클래스의 모든 속성과 메서드를 상속받아, 추가적인 기능을 구현하거나 기존 기능을 오버라이드(재정의)할 수 있음.

```javascript

Ext.define('MyApp.view.CustomPanel', {
    extend: 'Ext.panel.Panel',  // Ext.panel.Panel 클래스를 상속받습니다.
    // 커스텀 속성 및 메서드 추가...
});
```
### 💼 상속을 사용하는 이유:
- ###### 재사용성 향상: 공통적인 기능을 가진 부모 클래스를 만들고, 이를 상속받아 여러 커스텀 클래스에서 재사용할 수 있음.
- ######  코드 중복 최소화: 상속을 통해 기존 클래스의 기능을 재활용함으로써, 유사한 기능을 가진 여러 클래스에서 코드 중복을 줄일 수 있음.
- ###### 확장성 및 유지보수성: 상속 구조를 활용하면, 애플리케이션의 기능 확장 및 유지보수가 용이해집니다. 부모 클래스에서 변경사항이 발생하면, 이를 상속받은 모든 자식 클래스에 자동으로 적용됨.
## 🌟 비전공자를 위한 추가 설명:
##### 상속은 마치 가족 간에 유전 정보를 전달하는 것과 비슷. 부모로부터 특정 특성(속성과 메서드)을 물려받아, 자식은 그 특성을 기반으로 새로운 특성을 추가하거나 변경할 수 있음. 즉, 상속을 통해 기존의 '레시피'를 바탕으로 새로운 '요리'를 만드는 것처럼, `Ext JS`에서도 `extend` 속성을 사용하여 기존 클래스의 '레시피'를 활용하고, 여기에 새로운 기능을 '추가'하거나 '변경'하여 새로운 클래스를 '만들어낼' 수 있음.
---

# 🌈 Ext JS MVC 아키텍쳐 (MVC Architecture) 🏛️🖥️
### 프로젝트 생성 📂

#### CMD 열고 Workspace 이동 📂
###### CMD (Command Prompt)를 열고 Ext JS 애플리케이션이 저장될 작업 공간으로 이동.

```plaintext
C:\>cd WorkspaceExtjs
```
### 애플리케이션 생성 🛠️
#### `sencha` 명령어를 사용하여 `Ext JS SDK`를 기반으로 새 `MVC` 애플리케이션을 생성.

```plaintext
C:\WorkspaceExtjs>sencha -sdk C:\SenchaSdk generate app classic MvcApp ./MvcApp
```
#### 개발 모드로 빌드 🏗️
##### 생성된 MvcApp 폴더로 이동한 후, 개발 모드로 애플리케이션을 빌드.

```plaintext
C:\WorkspaceExtjs\MvcApp>sencha app build development
```

### 🌐 애플리케이션을 개발 서버에 배포
#### 필요한 라이브러리 수정 📚
##### 애플리케이션에 필요한 추가 라이브러리나 설정 변경이 필요한 경우, app.json 파일에서 수정.

### MvcApp 폴더의 내용 복사 📋
###### MvcApp 폴더에 있는 모든 내용을 선택하여 복사.

### 톰캣 개발 서버에 배포 🚀
##### 톰캣(Tomcat) 개발 서버의 webapps\ROOT 폴더로 이동. 기존에 있는 WEB-INF 폴더를 제외한 모든 파일과 폴더를 삭제하고, MvcApp 폴더에서 복사한 내용을 붙여넣고 톰캣 을 실행.

```plaintext
C:\tomcat\webapps\ROOT> (MvcApp 내용 붙여넣기)
```
```plaintext
C:\tomcat\bin>startup
```
#### localhost:8080 접속
##### 이 과정을 통해 `Ext JS` 기반의 `MVC `애플리케이션을 개발하고, 개발 서버에 배포할 수 있음. 🌍🔧
###### Main.js 에 iconCls: 'x-fa fa-th-list' 로 수정 (아이콘이 꺠진다면)
---


## 🚀 Ext JS 애플리케이션 시작 프로세스
- #####  index.html 호출: 애플리케이션의 시작점인 index.html이 브라우저에 의해 먼저 호출. 🌐

- ##### bootstrap.js 호출: index.html은 bootstrap.js를 호출하여 애플리케이션의 초기 설정을 로드.📂

- ##### bootstrap.json 호출: bootstrap.js는 다음으로 bootstrap.json을 호출하여 애플리케이션에 필요한 패키지들과 경로들을 정의. 🛠️

- ##### app.js 호출: 마지막으로, app.js가 호출되며 여기서 mainView: 'MvcApp.view.main.Main'으로 첫 페이지를 정의. 📌

### 🏗️ Ext JS MVC Architecture
#### `Ext JS` 애플리케이션이 시작되면, 다음과 같은 구성요소로 이루어진 `MVC` 아키텍처를 따름:

#### 모델: 데이터 구조

```javascript
// '사람'을 나타내는 모델을 정의. 이름, 이메일, 전화번호 필드를 포함.
Ext.define('App.model.Person', {
    extend: 'Ext.data.Model', // Ext.data.Model을 상속.
    fields: [
        {name: 'name', type: 'string'},
        {name: 'email', type: 'string'},
        {name: 'phone', type: 'string'}
    ]
    // 모델은 데이터 유효성 검사, 연관관계, 사용자 정의 메서드를 포함할 수 있음
});
```

#### 뷰(View): 사용자 인터페이스
```javascript
// 사람 목록을 보여주는 그리드 패널 뷰를 정의합니다.
Ext.define('App.view.PersonList', {
    extend: 'Ext.grid.Panel', // Ext.grid.Panel을 상속받습니다.
    title: '사람 목록',
    store: 'Persons', // 'Persons' 스토어와 바인딩합니다.
    // 컬럼은 모델 필드와 일치합니다.
    columns: [
        {text: '이름', dataIndex: 'name'},
        {text: '이메일', dataIndex: 'email'},
        {text: '전화번호', dataIndex: 'phone'}
    ]
});
```
#### 컨트롤러(Controller):
```javascript
// PersonList 뷰에서의 상호작용을 처리하는 컨트롤러를 정의합니다.
Ext.define('App.controller.Person', {
    extend: 'Ext.app.Controller',
    // UI 상호작용을 위한 이벤트 리스너를 설정합니다.
    init: function() {
        this.control({
            'personlist': { // 뷰의 xtype 또는 id를 참조
                itemclick: this.editPerson // 아이템 클릭 시 호출될 메서드
            }
        });
    },
    // 아이템 클릭 이벤트를 처리할 메서드를 정의합니다.
    editPerson: function(grid, record) {
        console.log(record.get('name') + '을 클릭했습니다.');
        // 사람 정보 수정 로직 추가...
    }
});
```
#### Store(스토어):
```javascript
// 사람 모델의 인스턴스를 저장하고 관리할 스토어를 정의합니다.
Ext.define('App.store.Persons', {
    extend: 'Ext.data.Store',
    model: 'App.model.Person', // 저장할 모델 지정
    // 서버에서 로드하는 대신 데모를 위한 인라인 데이터
    data: [
        {name: 'Jean Luc', email: "jeanluc.picard@enterprise.com", phone: "555-111-1111"},
        // 추가 인물 객체...
    ]
});
```


#### MVC 아키텍처를 통해 `Ext JS` 애플리케이션은 잘 조직되고, 유지보수가 용이하며, 확장성 있는 구조를 가질 수 있습니다.

- ##### Model (모델): 데이터와 애플리케이션의 비즈니스 로직을 담당. 데이터의 유효성 검사, 데이터 변환, 데이터와 관련된 로직 등을 포함할 수 있음. 모델은 데이터의 상태를 나타내며, 변경 사항이 발생하면 이를 뷰나 컨트롤러에 알림.
- ##### Views:사용자 인터페이스(UI) 구성 요소. 애플리케이션의 모델 데이터를 사용자에게 시각적으로 표현하며, 사용자의 입력을 받음. 뷰는 HTML, CSS, Ext JS의 UI 컴포넌트로 구성될 수 있음.
- ##### Controllers (컨트롤러): 사용자의 입력에 반응하여 모델과 뷰 사이의 상호작용을 조정. 컨트롤러는 애플리케이션의 이벤트 흐름을 관리하며, 사용자의 입력에 따라 모델을 업데이트하고 뷰를 통해 변화를 반영.
- ##### Stores (스토어): 모델의 인스턴스를 저장하고, 데이터를 관리 및 조작하는 방법을 제공. 스토어는 서버로부터 데이터를 로드하고, 필터링, 정렬, 그룹핑 등의 데이터 조작 작업을 수행할 수 있음.
- ##### Controller는 애플리케이션의 핵심: Controller는 애플리케이션의 이벤트 흐름과 비즈니스 로직을 제어하는 중심 역할. 사용자의 행동에 따라 모델을 업데이트하고, 뷰를 통해 변화를 반영. 🎮👨‍🔬
---
### 📝 Main.js 수정 실습
##### `Ext.define('MvcApp.view.main.Main', {...});` 코드를 수정하여, 간단한 UI를 구성. 아래는 수정된 코드 예시:

```javascript
// "Ext.define" 메서드를 사용하여 'MvcApp.view.main.Main'이라는 이름의 새로운 클래스를 정의.
Ext.define('MvcApp.view.main.Main', {
    // "extend" 키워드를 사용하여 Ext JS의 'Ext.panel.Panel' 클래스를 상속받음.
    // 이는 Main 클래스가 Panel 클래스의 모든 속성과 메서드를 사용할 수 있게 해줌.
    extend: 'Ext.panel.Panel',
    
    // "xtype"은 이 클래스의 별칭을 설정. 이 별칭을 통해 나중에 이 클래스의 인스턴스를 쉽게 생성.
    xtype: 'main',
 // alias:'widget.main',
    // "title" 속성은 이 패널의 상단에 표시될 텍스트를 정의.
    title:'MVC 아키텍쳐',
    
    // "layout" 설정을 통해 이 패널 내부에 포함될 컴포넌트들의 배치 방식을 정의.
    // 여기서는 'vbox'를 사용하여 수직으로 컴포넌트들을 배치.
    layout: {
        type: 'vbox'
    },
    
    // "bodyPadding"은 패널 내부의 여백을 설정. 여기서는 상하좌우 모두 10px로 설정.
    bodyPadding:'10 10 10 10',
    
    // "items" 배열은 이 패널에 포함될 자식 컴포넌트들을 정의.
    items: [{
        // 첫 번째 컴포넌트는 "textfield". 사용자로부터 텍스트 입력을 받을 수 있음.
        xtype: 'textfield',     
        fieldLabel: '제목',    // "fieldLabel"은 텍스트 필드 옆에 표시될 라벨을 정의.
        name: 'subject1'        // "name" 속성을 통해 이 텍스트 필드를 식별할 수 있는 이름을 설정.
    }, {
        // 두 번째 컴포넌트는 "button". 클릭 가능한 버튼을 생성.
        xtype: 'button',        
        text: '전달',           // "text" 속성은 버튼에 표시될 텍스트를 정의.
    }, {
        // 세 번째 컴포넌트도 "textfield". 다른 텍스트 필드의 입력값을 표시할 수 있음.
        xtype: 'textfield',     
        fieldLabel: '전달받은제목',
        name: 'subject2'
    }]
});
```
### xtype과 alias 설명

- **xtype: 'main'**
  - `xtype`은 Ext JS에서 컴포넌트를 간단하고 직관적으로 참조할 수 있는 식별자.
  - 예: `{ xtype: 'main' }`을 통해 이 컴포넌트의 인스턴스를 쉽게 생성할 수 있음.
  - 주로 UI 컴포넌트 생성 시 사용.

- **alias: 'widget.main'**
  - `alias`는 `xtype`과 유사하게 컴포넌트에 별칭을 부여하는 방식이지만, `widget.` 접두사를 사용해 UI 컴포넌트임을 명시.
  - `Ext.widget('main')`과 같이 사용하여 컴포넌트를 생성할 수 있음.
  - `alias`는 모델, 스토어, 플러그인 등 다양한 Ext JS 구성 요소에 보다 일반적으로 사용될 수 있음.

### 요약
- `xtype`과 `alias`는 모두 `Ext JS`에서 컴포넌트를 참조하고 생성하기 위한 유용한 방법.
- 둘 다 컴포넌트의 간결한 참조를 제공하지만, `alias`는 `xtype`보다 넓은 범위의 구성 요소에 적용될 수 있음.
- `xtype: 'main'`과 `alias: 'widget.main'` 모두 해당 컴포넌트를 쉽게 참조하고 인스턴스를 생성할 수 있게 해줌.
---
### 🌐 Ext JS MVC 아키텍처 실습 설명

Ext JS MVC 아키텍처에서는 뷰(`View`)에 직접 이벤트 핸들러를 배치하는 대신, 컨트롤러(`Controller`)를 통해 애플리케이션의 이벤트를 중앙에서 관리합니다. 이 방법은 애플리케이션의 비즈니스 로직과 사용자 인터페이스를 분리하여, 각각 독립적으로 관리할 수 있게 해 줍니다.

#### 📝 MVC 아키텍처의 핵심 구성 요소
- **모델(Model)**: 데이터와 관련된 로직을 처리.
- **뷰(View)**: 사용자에게 정보를 보여 주고, 사용자의 입력을 받음.
- **컨트롤러(Controller)**: 사용자의 입력에 반응하여 모델을 업데이트하고, 그 결과를 뷰에 반영.

#### 🔧 애플리케이션 설정 (`application.js`)
`MvcApp` 애플리케이션의 전반적인 설정은 `application.js`에서 이루어짐. 여기서 애플리케이션의 이름을 정의하고, 사용할 컨트롤러들을 등록.

```javascript
Ext.define('MvcApp.Application', {
    extend: 'Ext.app.Application',  // 'Ext.app.Application' 클래스를 상속받아 새 애플리케이션 클래스를 정의. 이는 애플리케이션의 기본 구조와 생명주기를 관리.
    
    name: 'MvcApp',  // 애플리케이션의 고유 이름을 설정. 이 이름은 애플리케이션 내에서 자원(리소스)을 참조할 때 사용.
    
    controllers:['AppController'],  // 이 애플리케이션에 사용될 컨트롤러들을 배열로 등록. 컨트롤러는 애플리케이션의 로직을 관리하는 주체.
    
    quickTips: false,  // 'quickTips' 설정을 false로 하여 기본적으로 빠른 도움말(툴팁) 기능을 비활성화.
    platformConfig: {  // 특정 플랫폼(여기서는 'desktop')에 대한 설정을 지정.
        desktop: {
            quickTips: true  // 데스크톱 환경에서는 빠른 도움말(툴팁) 기능을 활성화.
        }
    },

    // 애플리케이션이 업데이트 되었을 때 사용자에게 알리고, 페이지를 새로고침할지 여부를 묻는 메서드.
    onAppUpdate: function () {
        Ext.Msg.confirm('Application Update', 'This application has an update, reload?',
            function (choice) {
                if (choice === 'yes') {
                    window.location.reload();  // 사용자가 '예'를 선택하면, 페이지를 새로고침하여 애플리케이션을 업데이트 함.
                }
            }
        );
    }
});

```

- ######  Ext JS에서 클래스를 정의할 때, "extend" 키워드를 사용.
- ###### "extend" 키워드의 역할은 특정 클래스를 "상속" 받는 것. 즉, 해당 클래스의 모든 기능을 "물려받아" 사용할 수 있게 됨.

- ######  여기서 'Ext.app.Application'은 Ext JS 프레임워크에서 제공하는 애플리케이션의 기본 클래스.
- ###### 이 클래스는 Ext JS 애플리케이션을 구성할 때 필요한 기본적인 설정과 기능들을 포함하고 있음.
- ######  예를 들어, 애플리케이션의 시작점을 정의하거나, 글로벌 이벤트를 관리하고, 라우팅 설정을 할 수 있는 기능들이 이 클래스에 포함되어 있음.

- ###### "extend: 'Ext.app.Application'"이라고 작성함으로써,
- ######  우리는 'Ext.app.Application' 클래스의 모든 기능을 상속받는 새로운 애플리케이션 클래스를 정의하게 됨.
- ######  이렇게 함으로써, 기본적인 애플리케이션 기능은 물론이고, 우리만의 추가적인 설정이나 로직을 구현할 수 있게 됨.

- ######  상속을 통해 기존의 클래스 기능을 재사용하고, 필요에 따라 확장하여 사용할 수 있다는 점은 객체지향 프로그래밍의 큰 장점 중 하나.
- ######  이를 통해 코드의 중복을 줄이고, 유지보수성을 높이며, 애플리케이션의 구조를 체계적으로 관리할 수 있음.
---


### 📂 컨트롤러 설정 (AppController.js)
#### `app/controller` 폴더 내에 `AppController.js`를 생성하여 애플리케이션의 이벤트와 로직을 중앙에서 관리. 이 컨트롤러는 뷰의 이벤트를 감지하고 처리하는 역할을 담당.

### 🚀 애플리케이션 실행 흐름
- ###### 사용자는 `View`를 통해 애플리케이션과 상호작용함.
- ###### 발생한 이벤트는 `Controller`에 의해 처리됨.
- ###### Controller는 필요에 따라 `Model`을 업데이트하고, 그 결과를 `View`에 반영하여 사용자에게 피드백을 제공.
- ###### 이 구조를 통해 `Ext JS` 애플리케이션은 더욱 체계적이고 관리하기 쉬운 코드베이스를 가질 수 있으며, 크고 복잡한 애플리케이션 개발에 적합한 아키텍처를 제공. 🌟
---

### Ext JS Controller 예제 해석 📚
```javascript
// 'MvcApp.controller.AppController'라는 이름의 클래스를 정의. 이 클래스는 Ext JS의 기본 컨트롤러인 'Ext.app.Controller'를 상속받아 만들어짐.
Ext.define('MvcApp.controller.AppController', {
    // 'Ext.app.Controller'를 상속받음으로써, MVC 패턴의 컨트롤러로서 기능할 수 있는 다양한 메소드와 속성들을 이용할 수 있게 됨.
    extend: 'Ext.app.Controller',

    // refs는 컨트롤러가 관리할 뷰의 컴포넌트들에 대한 참조를 설정하는 부분. 이를 통해 컨트롤러 내의 다른 메소드에서 해당 컴포넌트들을 쉽게 참조할 수 있음.
    refs: {
        // 'main textfield[name=subject1]' 선택자를 통해, xtype이 'main'이고, name 속성이 'subject1'인 텍스트 필드 컴포넌트를 찾아 'subject1'이라는 이름으로 참조.
        subject1: 'main textfield[name=subject1]',
        // 마찬가지로 'subject2'이라는 이름으로 'main textfield[name=subject2]' 선택자에 해당하는 텍스트 필드 컴포넌트를 참조.
        subject2: 'main textfield[name=subject2]',
    },

    // control 객체는 이벤트 리스너를 설정하는 부분. 특정 이벤트가 발생했을 때 실행될 함수를 지정할 수 있음.
    control: {
        // 'main button[name=btnSend]' 선택자에 해당하는 버튼이 클릭되었을 때 'onSendClick' 메소드를 실행하도록 설정.
        'main button[name=btnSend]': {
            click: 'onSendClick'
        }
    },

    // 'onSendClick' 메소드는 버튼 클릭 이벤트가 발생했을 때 호출.
    onSendClick: function() {
        // 현재 함수에 전달된 인자들을 콘솔에 출력. 이는 디버깅 시 유용하게 사용될 수 있음.
        console.log('arguments', arguments);
        // 디버거를 활성화하여, 이 코드 지점에서 스크립트의 실행을 일시 중지합니다. 이를 통해 개발자 도구에서 변수의 상태 등을 확인할 수 있음.
        debugger;
        // 'subject1' 참조를 통해 해당 텍스트 필드의 현재 값을 가져옴.
        let value = this.getSubject1().getValue();
        // 가져온 값을 'subject2' 참조를 통해 다른 텍스트 필드의 값으로 설정.
        this.getSubject2().setValue(value);
    }
})
```
### 📌 Ext JS Controller의 핵심 요소 설명

#### `refs` 속성 사용하기
- ###### **개념**: `refs`는 컨트롤러에서 관리할 뷰 컴포넌트들에 대한 참조를 설정하는 속성. 
- ###### **용도**: 이를 사용함으로써, 컨트롤러 내에서 특정 컴포넌트를 쉽게 찾아내고 조작할 수 있음. 이는 코드의 가독성과 유지보수성을 크게 향상시킴.
- ###### **예시**: `'main textfield[name=subject1]'`은 main 뷰 내의 name 속성이 'subject1'인 텍스트 필드를 찾아 참조.

#### `control` 속성으로 이벤트 핸들링
- ###### **개념**: `control`은 컨트롤러가 관리하는 뷰 컴포넌트의 이벤트를 핸들링하는 속성.
- ###### **용도**: 이벤트 리스너를 컴포넌트 선택자와 함께 정의하여, MVC 패턴의 핵심인 모델-뷰-컨트롤러 간의 상호작용을 효율적으로 관리.
- ###### **예시**: `'main button[name=btnSend]': {click: 'onSendClick'}`은 name 속성이 'btnSend'인 버튼이 클릭되었을 때 `onSendClick` 메소드를 실행.

#### `console.log`로 디버깅하기
- ###### **개념**: `console.log`는 자바스크립트에서 가장 기본적이고 강력한 디버깅 도구.
- ###### **용도**: 개발자 콘솔에 메시지를 출력하여 애플리케이션의 실행 흐름을 파악하고, 문제를 진단하는 데 사용됨.
- ###### **예시**: `console.log('arguments', arguments);`는 함수에 전달된 인자들을 콘솔에 출력.

#### `debugger`를 사용한 디버깅
- ###### **개념**: `debugger`는 스크립트 실행을 특정 지점에서 중단하고, 개발자 도구에서 변수 상태를 확인하거나 단계별 실행을 수행할 수 있게 함.
- ###### **용도**: 복잡한 버그를 진단하거나 애플리케이션의 특정 부분에서 코드 실행을 멈추고 싶을 때 유용.
- ###### **예시**: `debugger;`는 코드가 이 지점에 도달하면 실행을 일시 중지하고 개발자 도구에서 디버깅을 시작.
---

# 🌈 Ext JS MVC 아키텍쳐 (MVC Architecture) II 🏛️ (스토어 사용)

## 🌟 Ext JS 모델 상세 설명

### 🛠️ Base 모델 정의
```javascript
Ext.define('MvcApp.model.Base', {
    extend: 'Ext.data.Model', // Ext JS의 기본 데이터 모델을 확장.
    schema: {
        namespace: 'MvcApp.model' // 이 모델과 상속받는 모델들의 네임스페이스를 설정.
    }
});
```
- #### 네임스페이스(namespace): 코드 내에서 모델을 구분하기 위한 고유 경로입니다. `MvcApp.model`로 설정함으로써, 이 네임스페이스 아래에서 모델 이름이 충돌하지 않도록 함.
### 📘 Personnel 모델 정의
```javascript
Ext.define('MvcApp.model.Personnel', {
    extend: 'MvcApp.model.Base', // Base 모델을 상속받아 공통 설정을 재사용.
    fields: [
        'name', 'email', 'phone' // 이 모델이 다루는 데이터 필드를 정의.
    ]
});
```
- #### 모델 상속: Base 모델에서 정의한 네임스페이스 설정을 상속받아, `Personnel` 모델도 동일한 네임스페이스 안에 위치하게 됨.
- #### 데이터 필드`(fields)`: 모델이 다루는 구체적인 데이터의 종류를 나타냄. 여기서는 이름, 이메일, 전화번호를 다루는 예시를 보여줌.
#### 🤔 왜 이렇게 구조를 나누는가?
- #### 재사용성: `Base` 모델에 공통적인 설정(예: 네임스페이스)을 정의함으로써, 여러 모델에서 이를 재사용할 수 있습니다. 이는 코드의 중복을 줄이고 유지보수를 용이하게 함.
- #### 구조화: 데이터 구조를 명확히 정의하고, 관련 로직을 모델 내에 캡슐화함으로써, 데이터 관리의 복잡성을 줄이고 애플리케이션의 가독성과 유지보수성을 향상시킴.
### 💡 모델 사용의 이점
- #### 데이터 바인딩: 모델을 통해 정의된 데이터 구조를 `UI` 컴포넌트와 쉽게 바인딩할 수 있어, 데이터의 변경이 `UI`에 자동으로 반영됨.
- #### 데이터 관리: 서버로부터 데이터를 로딩하거나, 데이터를 서버에 저장하는 과정에서 모델을 통해 데이터의 유효성 검사, 변환 등을 손쉽게 할 수 있음.
#### 이렇게 `Base` 모델과 `Personnel` 모델을 통해 `Ext JS`에서 데이터의 구조와 관리 방법에 대한 기초를 다질 수 있음. 🚀

## 🗃️ Ext JS 스토어: MvcApp.store.Personnel 상세 설명
#### 스토어란?
##### 스토어`(Store)`는 `Ext JS`에서 데이터를 관리하는 핵심 구성요소. 데이터 컬렉션을 관리하며, 데이터를 불러오고, 필터링하고, 정렬하는 등의 작업을 수행. 스토어는 모델(Model)과 연결되어, 모델이 정의한 구조에 따라 데이터를 저장.

### MvcApp.store.Personnel 스토어 설명
```javascript
Ext.define('MvcApp.store.Personnel', {
    extend: 'Ext.data.Store',  // Ext.data.Store를 상속받아 스토어 기능을 상속.

    alias: 'store.personnel',  // 'store.personnel' 별칭으로 스토어를 쉽게 참조할 수 있음.

    model: 'MvcApp.model.Personnel',  // 이 스토어에 저장될 데이터의 구조를 정의한 'MvcApp.model.Personnel' 모델을 사용.

    data: { items: [
        // 스토어에 초기에 저장될 데이터입니다. 실제 애플리케이션에서는 서버로부터 데이터를 받아옴.
        { name: 'Jean Luc', email: "jeanluc.picard@enterprise.com", phone: "555-111-1111" },
        { name: 'Worf', email: "worf.moghsson@enterprise.com", phone: "555-222-2222" },
        { name: 'Deanna', email: "deanna.troi@enterprise.com", phone: "555-333-3333" },
        { name: 'Data', email: "mr.data@enterprise.com", phone: "555-444-4444" }
    ]},

    proxy: {
        type: 'memory',  // 'memory' 타입의 프록시를 사용하여, 데이터를 메모리에 임시로 저장합니다. 실제 서버와의 통신이 필요할 경우, 이 부분을 변경.
        reader: {
            type: 'json',  // 데이터를 읽어올 때 JSON 형식으로 처리.
            rootProperty: 'items'  // JSON 데이터 중 items 키에 해당하는 데이터를 스토어 데이터로 사용.
        }
    }
});
```
### 메모리 프록시(memory proxy)란?
- #### 메모리 프록시는 데이터를 브라우저의 메모리 안에서만 관리하는 방식입니다. 개발 과정에서 초기 데이터를 설정하거나, 테스트 용도로 사용됩니다. 실제 서비스에서는 서버와의 통신을 위해 다른 타입의 프록시(예: `ajax, rest` 등)를 사용합니다.

### 스토어의 중요성
- #### 스토어는 `Ext JS`에서 데이터 관리의 핵심으로, `UI` 컴포넌트(예: 그리드(`grid`), 리스트(`List`) 등)와 데이터를 연결하는 역할을 함. 데이터가 변경될 때, 연결된 `UI` 컴포넌트들은 자동으로 업데이트되어 반응형 `UI`를 구현할 수 있음.

###### 🚀 이러한 구조는 데이터 관리를 체계적으로 할 수 있게 하며, 애플리케이션의 유지보수성과 재사용성을 높여줌.
---
```javascript
Ext.define('MvcApp.Application', {
    extend: 'Ext.app.Application',

    name: 'MvcApp',
    controller:['AppController'],
    models:['Personnel'],
    stores:['Personnel'],

    quickTips: false,
    platformConfig: {
        desktop: {
            quickTips: true
        }
    },
    // 애플리케이션이 업데이트 되었을 때 사용자에게 알리고, 페이지를 새로고침할지 여부를 묻는 메서드.
    onAppUpdate: function () {
        Ext.Msg.confirm('Application Update', 'This application has an update, reload?',
            function (choice) {
                if (choice === 'yes') {
                    window.location.reload();  // 사용자가 '예'를 선택하면, 페이지를 새로고침하여 애플리케이션을 업데이트 함.
                }
            }
        );
    }
});
```
### 🚀 Ext JS Application.js 해설

#### `Ext.define('MvcApp.Application', {...})`에서, 우리는 Ext JS 프레임워크를 사용하여 웹 애플리케이션의 핵심 구조를 정의. 

🔍 **Application 클래스 정의**
- **extend: 'Ext.app.Application'**:
  - `'Ext.app.Application'` 클래스를 상속받아, 애플리케이션의 시작점을 정의. 이 클래스는 애플리케이션의 초기화, 생명주기 관리 등을 담당.
  
- **name: 'MvcApp'**:
  - 애플리케이션에 고유한 이름을 지정. 이 이름을 통해 애플리케이션 내의 리소스를 찾을 수 있게 됨.
  
- **controllers: ['AppController']**:
  - 사용할 컨트롤러를 배열로 등록. 여기서 컨트롤러는 사용자의 입력과 애플리케이션의 데이터 처리 로직을 중개하는 역할을 함.

🔍 **모델과 스토어 설정**
- **models: ['Personnel']** 와 **stores: ['Personnel']**:
  - 이 부분에서는 애플리케이션에서 사용될 모델과 스토어를 등록합니다. `'Personnel'`이라고 지정된 부분은 실제로 `app/model/Personnel.js`와 `app/store/Personnel.js` 파일을 참조.
  - 모델은 애플리케이션에서 사용되는 데이터의 구조를 정의하는 역할을 하며, 스토어는 이러한 데이터 모델의 인스턴스를 저장하고 관리하는 컨테이너 역할을 함.
  - `alias` 속성은 스토어를 더 쉽게 참조할 수 있도록 별칭을 제공. 예를 들어, `'store.personnel'`이라고 설정하면, `Ext.getStore('personnel')`을 통해 전역에서 해당 스토어에 접근할 수 있음.

🔍 **기타 설정과 메서드**
- **quickTips**와 **platformConfig**:
  - 사용자 인터페이스의 작은 도움말(툴팁) 기능을 활성화하거나 특정 플랫폼(예: 데스크톱)에 대한 특수 설정을 지정할 수 있음.
  
- **onAppUpdate**:
  - 애플리케이션이 업데이트되었을 때, 사용자에게 알리고 페이지 새로고침 여부를 묻는 대화상자를 표시. 이를 통해 최신 상태의 애플리케이션을 유지할 수 있음.

###### 이렇게 정의된 `MvcApp.Application` 클래스는 애플리케이션의 전반적인 설정과 구조를 관리하는 핵심. 🌐 애플리케이션을 개발할 때 이 파일을 기점으로 모델, 뷰, 컨트롤러, 스토어 등을 구성하고 연결하여, Ext JS 기반의 웹 애플리케이션을 효율적으로 개발할 수 있음.
---

## 🌟 Ext JS에서의 데이터 표시: Main.js에 그리드 추가하기

#### `Ext JS` 애플리케이션에서 데이터를 표시하는 방법 중 하나는 그리드 컴포넌트를 사용하는 것. 아래 코드는 `Main.js` 파일에서 그리드를 추가하여, 사용자 인터페이스에 데이터를 표시하는 방법을 보여줌.

```javascript
Ext.define('MvcApp.view.main.Main', {
    extend: 'Ext.panel.Panel',
    xtype: 'main',
    title: 'MVC 아키텍쳐',
    layout: {
        type: 'vbox'
    },
    bodyPadding: '10 10 10 10',
    items: [
        {
            xtype: 'textfield',
            fieldLabel: '제목',
            name: 'subject1'
        },
        {
            xtype: 'button',
            text: '전달',
            name: 'btnSend'
        },
        {
            xtype: 'textfield',
            fieldLabel: '전달받은제목',
            name: 'subject2'
        },
        {
            xtype: 'grid',
            width: 300,
            height: 300,
            store: 'Personnel',
            columns: [
                { text: '이름', dataIndex: 'name', width: 100 },
                { text: '이메일', dataIndex: 'email', flex: 1 },
                { text: '전화번호', dataIndex: 'phone', flex: 1 }
            ]
        }
    ]
});
```
### 📘 그리드 컴포넌트 설명
- #### `xtype: 'grid'`: 이 구성 요소는 Ext JS의 그리드 컴포넌트를 사용하겠다는 것을 나타냄. 그리드는 행과 열로 데이터를 표시하는 테이블 형태의 `UI` 컴포넌트.
- #### store: 'Personnel': 그리드가 표시할 데이터는 'Personnel' 스토어에 의해 관리. 여기서 'Personnel'은 stores: ['Personnel']에서 애플리케이션에 등록된 스토어의 이름을 참조. 이 스토어는 app/store/Personnel.js 파일에 정의된 데이터와 구조를 기반으로 함.
- #### columns: 각 열은 그리드에 표시될 데이터의 종류를 나타냅니다. dataIndex 속성은 모델에 정의된 필드와 일치해야 합니다.
## 🚀 왜 대문자로 'Personnel'을 사용하는가?
#### `Ext JS`에서 스토어를 참조할 때 대문자를 사용하는 것은 해당 스토어의 클래스 이름을 직접 참조하기 때문. `Ext.define`으로 정의된 클래스 이름은 대소문자를 구분하며, 일반적으로 클래스 이름은 대문자로 시작. 따라서, `store: 'Personnel'`에서 `'Personnel'`은 `MvcApp.store.Personnel` 클래스를 참조하며, 이는 스토어가 정의된 파일의 경로와 이름을 기반으로 함.

### 🌐 MVC 아키텍처에서의 데이터 흐름
- #### 모델(Model): 데이터의 구조를 정의합니다. 여기서는 `'MvcApp.model.Personnel'`이 그 역할을 함.
- #### 스토어(Store): 하나 이상의 모델 인스턴스를 저장하고 관리합니다. `'Personnel'` 스토어는 이 모델의 인스턴스들을 담고 있으며, 그리드와 바인딩되어 UI에 데이터를 공급.
- #### 뷰(View): 사용자에게 보여지는 인터페이스를 구성. 여기서는 그리드를 포함한 `Main` 패널이 뷰의 역할을 함.
- ####  컨트롤러(Controller): 사용자의 입력과 애플리케이션의 데이터 처리를 중계. 필요한 경우, 스토어와 모델을 업데이트

### 🌟 Ext JS에서 데이터 추가하기: onSendClick 이벤트 핸들러 구현

### 아래 코드는 `onSendClick` 함수를 사용하여 사용자가 버튼을 클릭했을 때 스토어에 새로운 데이터를 추가하는 방법을 보여줌. 이 예제는 `MvcApp.controller.AppController` 내에 정의.

```javascript
onSendClick: function() {
    // 'Personnel' 스토어에 접근하여 새로운 데이터 추가
    Ext.getStore('Personnel').add({
        name: '홍길동',
        email: "mr.data@enterprise.com",
        phone: "555-444-4444"
    });
}
```
### 📘 onSendClick 함수 설명
- #### `Ext.getStore('Personnel')`: 애플리케이션에 등록된 `'Personnel'` 이름의 스토어를 찾아서 반환. 이 스토어는 앞서 `app/store/Personnel.js`에 정의되었으며, `MvcApp.store.Personnel `클래스의 인스턴스.
- ####  .add({...}): 스토어의` add `메소드를 사용하여 새로운 데이터를 스토어에 추가. 여기서 전달된 객체는 `MvcApp.model.Personnel` 모델의 구조를 따름.
### 🚀 데이터 추가의 흐름
#### 사용자가 UI에서 '전달' 버튼을 클릭.
- ####  onSendClick 이벤트 핸들러가 실행되면서, 지정된 데이터가 `'Personnel'` 스토어에 추가됨.
- #### 스토어와 바인딩된 `UI` 컴포넌트(예: `그리드`)는 스토어의 변경 사항을 감지하고 자동으로 업데이트됨. 이를 통해 사용자는 새로 추가된 데이터를 `UI`에서 바로 볼 수 있음.
### 🌐 MVC 아키텍처에서의 역할
- ####  뷰(View): 사용자의 입력을 받는 인터페이스 역할을 함. 여기서는 버튼 클릭이 그 예.
- ####  컨트롤러(Controller): 사용자의 입력에 반응하여 스토어에 데이터를 추가하는 로직을 담당.
- ####  스토어(Store): 데이터를 관리하며, 컨트롤러로부터 데이터를 받아 `UI`에 반영.
##### 이 방식은 Ext JS의 MVC 아키텍처를 따라 데이터 관리와` UI `업데이트를 효율적으로 수행할 수 있게 합니다. 데이터 관리 로직을 중앙에서 처리함으로써 애플리케이션의 구조를 명확하게 하고, 유지 보수를 용이하게 만듦.

## 🎛️ 컨트롤러(Controller)의 역할과 작동 원리
##### 컨트롤러는 MVC 아키텍처에서 핵심적인 역할을 수행하는 컴포넌트 중 하나. 사용자의 입력을 받아 처리하고, 애플리케이션의 데이터 처리를 중계하는 중추적인 역할을 담당. 이 과정에서, 필요에 따라 스토어와 모델을 업데이트하여 데이터의 변화를 관리하고, 이를 뷰에 반영하여 사용자 인터페이스를 최신 상태로 유지.

### 📌 컨트롤러의 주요 기능:
- #### 이벤트 처리: 사용자의 액션(예: 버튼 클릭, 폼 제출 등)에 대한 이벤트 리스너를 등록하고 처리. 이를 통해 사용자의 입력에 적절한 반응을 할 수 있음.

- ####  데이터 관리: 모델과 스토어를 통해 애플리케이션의 데이터를 관리. 컨트롤러는 스토어에서 데이터를 조회하거나 업데이트하고, 이 변경사항을 모델에 반영하여 애플리케이션의 상태를 최신으로 유지.

- ####  뷰 업데이트: 데이터의 변경사항을 뷰에 반영하여 사용자 인터페이스를 업데이트. 이 과정은 주로 데이터 바인딩을 통해 자동으로 수행되며, 컨트롤러는 이 과정을 조정하고 관리.

## 🚦 작동 원리:
- #### 사용자가 UI에서 특정 액션을 수행(예: '전달' 버튼 클릭).
- #### 컨트롤러는 해당 액션에 매핑된 이벤트 리스너(예: `onSendClick)`를 통해 이벤트를 감지하고 처리 로직을 실행.
- #### 이 로직에 따라 필요한 데이터 변경사항이 스토어를 통해 모델에 반영.
- #### 스토어와 연결된 뷰는 스토어의 변경사항을 감지하고 자동으로 `UI`를 업데이트.
- #### 결과적으로, 사용자는 데이터의 최신 상태를 반영한 인터페이스를 볼 수 있게 됨.
- #### 컨트롤러는 이렇게 사용자의 입력과 애플리케이션의 데이터 처리 사이를 효율적으로 중계하며, 애플리케이션의 로직과 흐름을 관리. 이는 애플리케이션의 구조를 명확하게 하고, 각 컴포넌트의 역할을 분명히 하여 개발과 유지 보수를 용이하게 함.
---
# 🌈 Ext JS MVVM 아키텍처 (Architecture) (Model-View-ViewModel)

## 📚 Ext JS MVVM 아키텍처 개요

#### Ext JS에서의 MVVM (Model-View-ViewModel) 아키텍처는 애플리케이션을 더욱 체계적으로 구성할 수 있는 방법을 제공합니다. 이 아키텍처는 크게 세 가지 주요 구성 요소로 나뉩니다.

## 1. Model 📦
- **역할**: 애플리케이션의 데이터와 비즈니스 로직을 담당.
- **특징**: 데이터의 저장 및 관리, 비즈니스 규칙의 실행 등을 담당하며, 직접적으로 사용자 인터페이스`(UI)`와 상호작용하지 않음.

## 2. View 🖼️
- **역할**: 사용자에게 데이터와 상호작용 인터페이스를 시각적으로 표현함.
- **특징**: `HTML, CSS, JavaScript` 등을 사용하여 구현되며, 사용자의 입력을 받고, 사용자에게 정보를 시각적으로 제공함.

## 3. ViewModel 🧠
- **역할**: `View`와 `Model` 사이의 중재자 역할을 합니다. `View`에 표시될 데이터를 준비하고, 사용자의 입력을 처리하여 Model에 반영함.
- **특징**: 데이터 바인딩과 명령 바인딩을 통해 View와 Model 사이의 동기화를 자동화 함. 이를 통해 `View`는 `ViewModel`에 정의된 데이터와 상태에 따라 자동으로 업데이트 됨.

## 💡 MVVM 아키텍처의 장점
- **모듈성**: 화면 단위로 컴포넌트를 나누어 관리할 수 있어, 대규모 애플리케이션 개발 시 코드의 관리와 유지보수가 용이함.
- **재사용성**: `ViewModel`을 통해 데이터와 로직을 처리하므로, 비슷한 구조의 다른 `View`에서도 동일한 ViewModel을 재사용할 수 있음.
- **테스트 용이성**: `UI` 로직이 `ViewModel`에 분리되어 있기 때문에, 사용자 인터페이스를 건드리지 않고도 데이터 처리 로직을 테스트할 수 있음.

## 🛠️ Ext JS MVVM 아키텍처 구현 예제

#### Ext JS 애플리케이션 생성
```plaintext
C:\WorkspaceExtjs>sencha -sdk C:\SenchaSdk generate app classic MvvmApp ./MvvmApp
```

#### 애플리케이션 빌드
```plaintext
C:\WorkspaceExtjs\MvvmApp>sencha app build development
```
### 📦 Tomcat 개발서버 복사 설명은 생략하겠습니다

#### 위의 내용에서 많은 정보를 다루었기 때문에, Tomcat 개발서버로의 복사 과정에 대한 설명은 생략하겠습니다. 필요한 기본 정보와 명령어는 이미 제공되어있어요. 🚀
---
## 🎮 Ext JS MVVM 아키텍처에서의 컨트롤러

#### MVVM 아키텍처 내에서 컨트롤러는 주로 다음과 같은 역할을 수행:

### 1. 이벤트 처리 🎉
- **설명**: 뷰에서 발생하는 사용자 이벤트(예: 버튼 클릭, 폼 제출 등)를 감지하고, 이에 대한 반응으로 적절한 로직(예: 데이터 검증, 모델 업데이트 등)을 실행.
- **특징**: 이벤트 처리 로직을 뷰모델이나 뷰로부터 분리함으로써, 코드의 가독성과 유지보수성을 향상시킬 수 있음.

### 2. 애플리케이션 로직 실행 🔍
- **설명**: 애플리케이션 전반에 걸친 공통 로직(예: 페이지 전환 로직, 전역 상태 관리 등)을 처리.
- **특징**: 특정 뷰나 뷰모델에 종속되지 않는 애플리케이션 수준의 로직을 관리함으로써, 애플리케이션의 구조를 더욱 명확하게 할 수 있음.

### 3. 뷰와 뷰모델 간의 조정 🤝
- **설명**: 복잡한 데이터 바인딩이나, 뷰모델 간의 상호작용을 조정하는 역할을 할 수도 있음.
- **특징**: 뷰와 뷰모델의 결합도를 낮추어, 각각의 재사용성과 테스트 용이성을 높일 수 있음.

### 결론 ✨
##### `MVVM` 아키텍처에서 컨트롤러는 뷰와 뷰모델 사이의 상호작용을 원활하게 하고, 애플리케이션의 흐름을 제어하는 중요한 역할을 함. 비록 `MVVM` 아키텍처가 뷰모델에 중점을 두고 있지만, 특정 시나리오에서 컨트롤러의 역할은 여전히 중요함.
---
# 🛠️ ExtJS MVVM 아키텍처에서의 MainController 및 Main View 설정하기

ExtJS MVVM 아키텍처를 구현할 때 중요한 두 파일, `Main.js`와 `MainController.js`의 설정 방법을 살펴보겠습니다. 이 설명은 비전공자도 이해할 수 있도록 기초적인 개념과 설정 방법에 초점을 맞춥니다.

## 📂 Main.js 수정하기

#### `Main.js` 파일은` ExtJS` 애플리케이션의 시작점이며, 여기서 애플리케이션의 전반적인 레이아웃과 설정을 정의.

### 1. **MVCapp의 `main.js` 복사 후 MVVM 아키텍처로 이름 변경**
   - #### 기존 MVC 애플리케이션의 `main.js` 파일을 복사.
   - #### 복사한 파일을 MVVM 아키텍처에 맞게 이름을 변경. 이렇게 하면 기존의 설정을 기반으로 새로운 아키텍처를 쉽게 적용할 수 있음.

### 2. **그리드 제거**
   - #### MVVM 아키텍처에 불필요한 그리드`(grid)` 관련 코드를 제거합니다. MVVM은 모델`(Model)`, 뷰`(View)`, 뷰모델`(ViewModel)`의 분리에 중점을 두기 때문에, 필요에 따라` UI` 구성 요소를 조정해야 할 수 있음.

## 🎮 MainController.js 설정하기

#### `MainController.js`에서는 애플리케이션의 사용자 인터페이스 로직을 처리. 이 파일에서 뷰 컨트롤러를 정의하여, 뷰와 모델 간의 상호작용을 관리.

### 파일명 규칙
- #### `MainController.js`의 파일명은 관련된 뷰의 이름을 따름. 이는 코드의 가독성과 유지 관리를 용이하게 함.
- #### `Ext.app.ViewController`를 상속(extend)하여 뷰 컨트롤러의 기능을 사용.

### Alias 설정
- #### Alias는 `'controller.main'`으로 설정. 이는 뷰에서 해당 컨트롤러를 참조할 때 사용하는 고유한 식별자입니다.
- #### 뷰에서는 일반적으로 `widget.`을 사용하지만, 컨트롤러에서는 `controller.`를 사용합니다. 이 구분은 `ExtJS`의 내부 규칙에 따른 것으로, 뷰와 컨트롤러를 명확하게 구분하기 위한 목적을 가짐.

## 결론

#### ExtJS의 MVVM 아키텍처에서 `Main.js`와 `MainController.js`의 설정은 애플리케이션의 구조를 정의하는 중요한 단계. `Main.js`는 애플리케이션의 진입점으로서 전반적인 구성을 담당하며, `MainController.js`는 사용자의 인터랙션과 뷰의 동적 요소를 관리. 이러한 설정을 통해, `ExtJS` 애플리케이션의 유지보수성과 확장성을 크게 향상시킬 수 있음.

#### 파일명 규칙: `MainController.js` 파일명은 관련된 뷰의 이름을 따름. 확장 상속을 받아 사용하기 때문에, Ext.app.ViewController를 extend하여 사용.
##### Alias 설정: Alias는 'controller.main'으로 정의합니다. `View`에서는 `widget.`으로 시작하지만, 뷰 컨트롤러에서는 `controller.`로 시작하는 것이 일반적. 이는 `ExtJS`의 내부적인 규칙에 따른 것으로, 뷰와 컨트롤러를 명확하게 구분하기 위함.

## 🎮 MainController.js 설정 및 뷰와의 연결 방법

### `MainController.js`는 애플리케이션의 사용자 인터페이스 로직을 처리하는 곳 이 파일을 통해 정의된 뷰 컨트롤러는 뷰와 모델 간의 상호작용을 효과적으로 관리하게 됨. 아래는 `MainController.js` 설정과 뷰와의 연결 방법에 대한 자세한 설명.

### 파일명 규칙 및 상속
- #### **파일명 규칙**: `MainController.js`의 파일명은 연결될 뷰의 이름을 따라갑니다. 이러한 규칙은 코드의 가독성 및 유지보수를 용이하게 함.
- #### **상속**: `Ext.app.ViewController`를 상속(extend)하여, 뷰 컨트롤러의 다양한 기능을 사용할 수 있음.

### Alias 설정과 뷰와의 연결
- **Alias 설정**: Alias는 `'controller.main'`으로 설정하면. 이 Alias는 뷰에서 특정 컨트롤러를 참조할 때 사용되는 고유한 식별자 역할을 함.
- **뷰와 컨트롤러의 연결**: 뷰에서 컨트롤러를 연결하기 위해, 뷰 정의 부분에 `controller: 'main'`과 같이 Alias를 명시함. 이 방법을 통해, `Ext.define`으로 정의된 컨트롤러와 뷰를 연결할 수 있음.

```javascript
// Controller
Ext.define('MvvmApp.view.main.MainController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.main',

// view
     Ext.define('MvvmApp.view.main.Main', {
    extend: 'Ext.panel.Panel',
    requires:['MvvmApp.view.main.MainController'],
    controller:'main',
});
```

### 명시적인 연결 설명
#### 뷰에서 `controller: 'main'`을 선언함으로써, `alias: 'controller.main'`으로 지정된 `MainController.js`와 뷰를 직접 연결. 이렇게 함으로써, 뷰 내에서 발생하는 이벤트나 동작들이 `MainController`에서 정의된 로직을 통해 처리될 수 있게 됨.
### 결론
#### `ExtJ`S의 `MVVM` 아키텍처에서 `Main.js`와 `MainController.js`의 설정은 애플리케이션의 핵심 구조를 정의. `Main.js`는 애플리케이션의 진입점이며, `MainController.js`는 사용자 인터랙션과 뷰의 동적 요소를 관리. `뷰`와 `컨트롤러`의 명시적 연결은 애플리케이션의 유지보수성과 확장성을 크게 향상시키며, 개발자가 뷰와 비즈니스 로직을 명확히 분리하여 관리할 수 있게 함.
---

# 🎨 ExtJS MVVM 아키텍처: Main View 및 Controller 연결하기 (복습)

#### ExtJS 애플리케이션에서 `Main.js`와 `MainController.js`의 설정과 연결은 사용자 인터페이스와 로직의 분리를 가능하게 하여, 애플리케이션의 구조를 명확하고 유지보수하기 쉽게 만듦. 여기서는 `Main.js` 설정과 `MainController`의 연결 과정을 자세히 설명.

## 📁 Main.js의 설정

#### `Main.js`는 애플리케이션의 중심이 되는 뷰를 정의. 이 파일에서는 사용될 컨트롤러와 필요한 컴포넌트를 선언.

```javascript
Ext.define('MvvmApp.view.main.Main', {
    extend: 'Ext.panel.Panel', // ExtJS 패널을 확장
    requires: ['MvvmApp.view.main.MainController'], // MainController를 포함시킴
    controller: 'main', // 해당 뷰의 컨트롤러를 지정
    xtype: 'main', // 이 뷰의 xtype 정의
    title: 'MVVC 아키텍쳐', // 패널의 제목
    layout: {
        type: 'vbox' // 수직 박스 레이아웃 사용
    },
    bodyPadding: '10 10 10 10', // 패딩 설정
    items: [{ // 뷰에 포함될 아이템들 정의
        xtype: 'textfield',
        fieldLabel: '제목',
        name: 'subject1',
        reference: 'subject1' // 나중에 컨트롤러에서 참조할 수 있게 이름 지정
    }, {
        xtype: 'button',
        text: '전달',
        name: 'btnSend',
        handler: 'onSendClick' // 버튼 클릭 이벤트 핸들러 지정
    }, {
        xtype: 'textfield',
        fieldLabel: '전달받은제목',
        name: 'subject2',
        reference: 'subject2' // 나중에 컨트롤러에서 참조할 수 있게 이름 지정
    }]
});
```
### 🔄 Main.js와 MainController.js의 연결
####  requires 선언
- ###### requires: ['MvvmApp.view.main.MainController']를 사용하여 `MainController.js` 파일을 현재 뷰에 포함시키는 것과 같음. 이는 `JAVA`의 `import` 문과 비슷한 역할을 하여, 필요한 외부 파일을 현재 컴포넌트로 가져오는 역할을 함.
#### controller 속성
- ###### controller: `'main'`을 통해 현재 뷰에 사용될 컨트롤러를 지정. 이때 `'main'`은 `MainController.js`에서 정의된 `alias: 'controller.main'`에 해당. 이렇게 설정함으로써, 뷰는 해당 컨트롤러의 로직을 사용할 수 있게 되며, 사용자 인터랙션이나 데이터 처리 로직을 뷰에서 분리할 수 있음.
### 🎉 결론

#### `Main.js`의 설정과` MainController.js`의 연결 과정을 통해` ExtJS MVVM` 아키텍처에서 뷰와 컨트롤러를 효과적으로 관리할 수 있고. 이 구조는 개발자가` UI`와 비즈니스 로직을 분리하여 관리할 수 있게 하여, 애플리케이션의 유지보수성과 확장성을 향상시킴. 🌟

## 🌟 ExtJS MVVM 아키텍처: 이벤트 핸들링과 컴포넌트 참조

#### `ExtJS`에서 `MVVM` 아키텍처를 사용하면, 이벤트 핸들링과 컴포넌트 참조가 매우 직관적이고 간결해짐. 여기서는 `MainController.js`에서 버튼 클릭 이벤트를 처리하는 방법과, 텍스트 필드에 접근하는 방법을 살펴보자.

### 🖱️ 이벤트 핸들링

#### `ExtJS MVVM` 아키텍처에서 이벤트를 핸들링하는 방식은 간단하며, 이벤트 핸들러를 문자열로 직접 지정.

```javascript
{
    xtype: 'button',
    text: '전달',
    // name: 'btnSend', // 이제 name 속성은 주석 처리해도 됨.
    handler: 'onSendClick' // 버튼 클릭 시 호출될 핸들러
}
```
- #### handler 속성: 이는 버튼 클릭 이벤트에 반응하여 호출될 함수의 이름을 문자열로 지정. 여기서 `'onSendClick'`은 `MainController.js `내에 정의될 함수.
### 📋 컴포넌트 참조
- #### `MVVM `아키텍처에서는 `reference` 속성을 사용하여 뷰 내의 컴포넌트를 쉽게 참조할 수 있음. 이는 컨트롤러에서 해당 컴포넌트에 직접 접근할 수 있게 해줌.

```javascript
{
    xtype: 'textfield',
    fieldLabel: '제목',
    reference: 'subject1' // 컴포넌트를 참조하는 데 사용될 이름
},
{
    xtype: 'textfield',
    fieldLabel: '전달받은제목',
    reference: 'subject2'
}
```
- #### reference 속성: 특정 컴포넌트를 나중에 쉽게 찾을 수 있도록 참조 이름을 지정.
### 🎮 MainController에서의 이벤트 처리
- #### `MainController.js`에서는 `handler`에 지정된 이벤트 이름과 동일한 함수를 정의하여, 해당 이벤트를 처리.

```javascript
Ext.define('MvvmApp.view.main.MainController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.main',
    onSendClick: function() {
        let value = this.lookupReference('subject1').getValue(); // subject1 참조로 값을 가져옴
        this.lookupReference('subject2').setValue(value); // subject2 참조에 값을 설정
    }
});
```
- #### `lookupReference` 메서드: `reference`로 지정된 컴포넌트를 찾아 작업을 수행. 이 메서드는 `MVVM` 아키텍처에서 컴포넌트에 접근하는 표준 방법.
### 🔄 MVC와 MVVM의 차이점
- #### `MVC`: `MVC` 아키텍처에서는 `refs`를 사용하여 뷰 컴포넌트에 접근했고, 모든 참조가 중앙 컨트롤러에서 관리되었음.
- #### `MVVM`: 반면, `MVVM` 아키텍처에서는 뷰에서 직접 `reference`를 정의하고, 컨트롤러에서 `lookupReference`를 통해 해당 컴포넌트를 쉽게 찾아 사용할 수 있음. 이는 코드의 간결성을 높이고, 뷰와 로직의 분리를 명확하게 함.
###### `MVVM` 아키텍처의 이벤트 핸들링과 컴포넌트 참조 방법은 애플리케이션 개발을 더욱 효율적이고 유지보수하기 쉽게 만들어줌. 🌈
---

# 🌈 Ext JS MVVM 아키텍처 (Architecture) II (Model-View-ViewModel) (스토어 사용)

###  MVVM 아키텍처에서의 스토어 사용 방법

#### MVVM 아키텍처에서는 `ViewModel`이 중심 역할을 함. `ViewModel`은 뷰의 상태와 데이터를 관리하며, 데이터 바인딩을 통해 뷰와 모델 사이의 연결고리 역할을 함. ExtJS에서 MVVM 아키텍처를 적용하기 위해 다음 단계를 따라보자.

## 기존 MVC 아키텍처 코드

- **Main.js (뷰)**
    - ####  이전에는 `store: 'Personnel'`과 같이 직접 스토어를 지정.

- **MainController.js (컨트롤러)**
- **MainModel.js (모델)**

#### 이 세 파일은 MVC 아키텍처에서 함께 사용되었으며, MVVM으로 전환 시 `MainModel.js`가 `ViewModel`의 역할을 하게 됨.

## MVVM 아키텍처 적용

1. **ViewModel 생성 (MainModel.js)**
   - `MainModel.js` 파일 경로: `MvvmApp.view.main.MainModel`
   - `alias` 설정: `alias: 'viewmodel.main'`
   - 이 `ViewModel`은 뷰의 데이터와 상태를 관리.

2. **스토어 정의 변경**
   - MVVM 아키텍처에서는 스토어를 `ViewModel` 내에 정의하여 사용.
```javascript
   stores: {
       personalInfo: {
           data: [
               { name: 'Jean Luc', email: "jeanluc.picard@enterprise.com", phone: "555-111-1111" },
               ...
           ],
           proxy: {
               type: 'memory',
               reader: {
                   type: 'json',
                   rootProperty: 'items' // 'items' 속성은 'memory' 타입 프록시에서 생략 가능
               }
           }
       }
   }
```

#### 여기서 data 속성에 직접 데이터를 배열로 넣어줄 수 있으며, proxy를 통해 데이터 관리 방식을 정의.
### 뷰와 스토어의 바인딩
#### 뷰에서 스토어를 사용하기 위해 이전에는 `store: 'Personnel'`로 직접 지정했던 부분을 바인딩을 통해 변경.
``` javascript
bind: {
    store: '{personalInfo}'
}
```
#### 이렇게 설정하면, ViewModel에 정의된 personalInfo 스토어가 해당 뷰와 연결됨.

###  Main.js, MainController.js, MainModel.js의 관계

#### `ExtJS`에서의 애플리케이션 구조는 주로 세 가지 주요 파일로 구분: 뷰(`main.js`), 컨트롤러(`MainController.js`), 그리고 모델(`MainModel.js`). MVVM 아키텍처에서는 이들 간의 관계가 애플리케이션의 구조와 동작 방식을 정의.

### 파일 구성 및 역할

- #####  **main.js (뷰)**
  - 사용자 인터페이스와 사용자 경험을 정의하는 파일. 화면에 보이는 구성 요소들과 레이아웃을 정의.

- ##### **MainController.js (컨트롤러)**
  - 사용자의 입력과 애플리케이션의 이벤트 처리를 담당. 뷰에서 발생하는 이벤트에 대한 로직을 구현.

- ##### **MainModel.js (뷰모델)**
  - 데이터와 관련된 로직, 애플리케이션의 상태 관리를 담당. MVVM 아키텍처에서는 뷰모델이 중요한 역할을 함.

## 선택적 사용

#### 개발 과정에서 `MainModel.js` (뷰모델)을 사용하지 않고, `main.js`와 `MainController.js`만 사용하여 애플리케이션을 구현하는 경우가 종종 있음. 이는 아래와 같은 이유 때문:

- #### **단순한 로직이나 작은 프로젝트의 경우**: 프로젝트의 복잡성이 낮거나, 데이터 관리가 중심이 아닐 때 뷰모델을 별도로 분리하지 않고, 컨트롤러 내에서 간단한 데이터 처리를 수행하기도 함.

- #### **유연성과 단순성을 추구할 때**: 때로는 뷰모델을 분리하는 것이 오히려 관리 포인트를 늘리고 복잡성을 증가시킬 수 있음. 이 경우, 뷰와 컨트롤러만을 사용하여 애플리케이션을 구성하며, 간결하고 유연한 구조를 유지할 수 있음.

## 결론

#### `main.js`, `MainController.js`, `MainModel.js` 세 파일의 관계와 사용 방식은 프로젝트의 요구사항과 개발자의 선호도에 따라 달라질 수 있음. MVVM 아키텍처를 사용하더라도, 프로젝트의 특성에 맞춰 가장 적합한 구조를 선택하는 것이 중요.
---

# ExtJS의 MVVM 아키텍처를 이용한 데이터 관리와 UI 업데이트 🌐
```javascript
this.getViewModel().getStore('personalInfo').add({ name: '홍길동', email: "jeanluc.picard@enterprise.com", phone: "555-111-1111" });
```

### ExtJS에서 제공하는 `MVVM(Model-View-ViewModel)` 아키텍처는 데이터 관리와 UI 업데이트를 매우 효율적으로 만들어 준다. 사용자가 UI에서 특정 액션(예: 버튼 클릭)을 수행할 때, 이에 반응하여 데이터를 업데이트하고 이 변경사항을 자동으로 UI에 반영하는 프로세스를 살펴보자.

## 1️⃣ 현재 컨트롤러 인스턴스 가져오기: `this.getViewModel()`

- #### **`this`**: 현재의 컨트롤러 인스턴스를 나타냄. 컨트롤러는 뷰와 연결되어 있으며, 뷰에서 발생하는 이벤트(예: 사용자 입력, 버튼 클릭 등)를 처리.
- #### **`getViewModel()`**: 이 메서드는 컨트롤러와 연결된 ViewModel을 반환. ViewModel은 뷰에 표시되는 데이터와 상태를 관리하며, 이를 통해 UI의 데이터를 업데이트.

## 2️⃣ 스토어 찾기: `.getStore('personalInfo')`

- #### **`getStore('personalInfo')`**: ViewModel에서 `personalInfo`라는 이름의 스토어를 찾아 반환. 스토어는 애플리케이션의 데이터를 저장하고 관리하는 컨테이너 역할을 함. 여기서는 사용자의 이름, 이메일, 전화번호와 같은 정보를 저장.

## 3️⃣ 스토어에 데이터 추가: `.add(...)`

- #### **`.add(...)`**: 이 메서드를 사용해 스토어에 새로운 데이터 항목을 추가. 예시에서는 `{ name: '홍길동', email: "jeanluc.picard@enterprise.com", phone: "555-111-1111" }`와 같은 새 사용자 정보를 스토어에 추가.

## 🔄 작동 원리

- #### **버튼 클릭 시**: 사용자가 "전달" 버튼을 클릭하면 `onSendClick` 함수가 호출.
- #### **스토어 업데이트**: 이 함수는 `personalInfo` 스토어를 찾아 새로운 사용자 정보를 추가.
- #### **UI 자동 반영**: 데이터가 스토어에 추가되면, 해당 스토어와 데이터 바인딩된 모든 UI 컴포넌트(예: 그리드)는 자동으로 업데이트되어 새로운 정보를 표시.

#### 이 과정을 통해, `ExtJS` 애플리케이션은 데이터 추가, 수정, 삭제 등의 작업을 한 곳에서 처리할 수 있으며, 이러한 변경사항이 관련된 모든 UI에 자동으로 반영. 이는 데이터 관리와 UI 업데이트를 매우 효율적으로 수행할 수 있게 해주는 MVVM 아키텍처의 강점. 💪
---
## ExtJS의 MVVM 아키텍처에서 `this`의 이해와 활용 🎓

### ExtJS에서 MVVM(Model-View-ViewModel) 아키텍처를 적용할 때, `this`의 사용과 그 중요성은 개발의 편리함과 직결됨. 이해하기 쉽도록, `this`가 가리키는 대상의 차이와 그로 인한 개발의 편의성에 대해 자세히 알아보자.

## 🤖 `this`가 가리키는 대상

### 1. 뷰(View)에서 `this`

- #### **버튼 이벤트 핸들러 내부에서의 `this`**: 버튼에서 정의한 이벤트 핸들러 내부에서 `this`는 해당 버튼 컴포넌트 자체를 가리킨다. 이는 `this`를 사용하여 직접적으로 버튼의 속성이나 메서드에 접근할 수 있음을 의미.
- #### **제한성**: 그러나 버튼이 아닌 다른 컴포넌트나 데이터에 접근하고자 할 때는 추가적인 작업이 필요함. 즉, `this.nextSibling('grid')`와 같이 상대적인 위치나 `this.up('panel').down('grid')`와 같이 상/하위 컴포넌트를 통해 접근해야 하며, 레이아웃의 변경에 따라 코드를 수정해야 할 수도 있음.

### 2. 뷰 컨트롤러(ViewController)에서 `this`

- #### **컨트롤러의 이벤트 핸들러에서의 `this`**: `MainController`와 같은 컨트롤러 내부에서 `this`는 컨트롤러 인스턴스 자체를 가리킨다. 이를 통해 컨트롤러는 뷰(View)와 뷰 모델(ViewModel)에 쉽게 접근할 수 있으며, UI 컴포넌트와 데이터 관리 로직을 효율적으로 연결할 수 있음.

## 🛠 `this`를 활용한 개발의 편의성

### 뷰 컴포넌트 접근

- #### **`this.lookupReference('subject1')`**: 특정 레퍼런스(reference)를 가진 컴포넌트를 쉽게 찾을 수 있음. 이 방법은 뷰 내의 컴포넌트 간 직접적인 연결 없이도 필요한 컴포넌트에 접근하게 해 줌.

### 데이터 관리

- #### **`this.getViewModel().getStore('personalInfo')`**: 컨트롤러에서 뷰 모델의 스토어에 직접 접근하여, 데이터를 추가하거나 수정할 수 있음. 이로 인해 데이터와 UI의 동기화가 자동으로 이루어지며, 개발자는 UI 업데이트를 위한 추가적인 작업을 할 필요가 없음.

## 🔄 MVVM 아키텍처의 장점 활용

#### 뷰 컨트롤러에서 `this`를 통해 로직을 처리함으로써 MVVM 아키텍처의 장점을 최대한 활용할 수 있습니다. 데이터 관리와 UI 업데이트가 효율적으로 연결되어, 애플리케이션의 유지보수성과 확장성이 향상됨. 🌟

- #### **데이터 바인딩**: 스토어에 데이터를 추가하면, 바인딩된 뷰가 자동으로 업데이트됨. 이는 개발자가 수동으로 UI를 갱신할 필요가 없게 만들어, 개발 과정을 간소화하고 오류 가능성을 줄여줌.

- #### **컴포넌트 접근의 용이성**: 컨트롤러에서는 `this`를 통해 모든 뷰 컴포넌트에 접근할 수 있는 방식이 제공되고. 이는 코드의 가독성을 높이고, 개발 효율성을 개선.

#### 결론적으로, MVVM 아키텍처에서의 `this` 사용은 ExtJS 애플리케이션의 개발을 더욱 강력하고 편리하게 만들어 , MVVM의 구조와 원리를 기억하며 ExtJS 프로젝트를 진행해 보자..! 💡
---
# 🌈 MVC + MVVM 아키텍처의 혼합 사용에 대한 이해 🌟

#### ExtJS와 같은 프레임워크에서, `MVC(Model-View-Controller)`와 `MVVM(Model-View-ViewModel)` 아키텍처는 각각의 장점을 가지고 있다. 때로는 이 두 아키텍처를 혼합하여 사용함으로써, 개발의 효율성과 유지보수성을 높일 수 있다. 이 글에서는 MVC와 MVVM의 혼합 사용 방법과 그 장점에 대해 설명.

## 📌 MVVM 아키텍처의 강점

- #### **중심이 되는 View**: MVVM에서는 뷰`(View)`가 중심이 되며, 뷰 컨트롤러`(ViewController)`와 뷰 모델`(ViewModel`)은 뷰에 의존적입니다. 뷰가 사라지면 이들도 함께 메모리에서 제거된다.
- #### **데이터 바인딩**: MVVM은 데이터 바인딩을 통해 모델과 뷰를 연결, 자동으로 UI가 업데이트되도록 함. 이는 코드의 양을 줄이고, 개발을 단순화시킴.

## 📌 MVC 아키텍처의 강점

- ####  **컨트롤러의 중심성**: MVC에서는 컨트롤러`(Controller)`가 애플리케이션의 로직을 중심으로 처리. 컨트롤러는 뷰나 모델에 대한 접근 및 조작을 주도함.
- #### **분리된 관심사**: MVC는 애플리케이션을 `Model`, `View`, `Controller`로 나눔으로써, 각 부분의 개발과 관리를 독립적으로 할 수 있게 함.

## 🔄 혼합 사용의 실제

- #### **글로벌 컨트롤러 활용**: 글로벌 컨트롤러(`MVC`)는 애플리케이션 전체에 걸친 공통 기능을 구현하는 데 유용. 예를 들어, 페이지 이동이나 공통 팝업 호출 같은 기능을 이 컨트롤러에서 처리할 수 있음.
- #### **뷰 및 뷰모델의 상속**: 개별 화면 개발 시, 뷰 컨트롤러와 뷰 모델`(MVVM)`을 상속받아 사용함으로써, 개발자는 특정 화면에 필요한 기능만을 추가로 구현하면 됨.

## 🛠️ 혼합 사용의 장점

- #### **효율적인 개발 프로세스**: 공통 기능은 `MVC`의 글로벌 컨트롤러에서, 화면별 특화 기능은 MVVM의 뷰 컨트롤러와 뷰 모델에서 각각 관리함으로써, 개발의 효율성과 재사용성을 극대화할 수 있음.
- #### **유지보수의 용이성**: 애플리케이션의 구조가 명확해지고, 각 부분의 역할이 분명해짐에 따라, 코드의 이해와 유지보수가 용이해짐ㅁ.

## 🎯 예시
```javascript
// 글로벌 컨트롤러(MVC)에서 페이지 이동 함수 구현
navigateToPage: function(pageName) {
    // 페이지 이동 로직 구현...
}

// 개별 뷰 컨트롤러(MVVM)에서 글로벌 컨트롤러의 함수 사용
onSomeAction: function() {
    this.getApplication().getController('GlobalController').navigateToPage('targetPage');
}
// 뷰모델(MVVM)에서 데이터 바인딩을 사용하여 UI 업데이트
ViewModel: {
    Properties: {
        // 바인딩할 데이터 정의
    }
}
```
# ExtJS 프로젝트 생성 및 빌드 과정 🚀

#### ExtJS 애플리케이션을 개발하기 위한 첫 단계는 프로젝트 생성부터 시작해보자. MVC와 MVVM 아키텍처를 혼합한 프로젝트를 만들고, 개발 모드로 빌드한 후, 결과물을 Tomcat 서버에 배포하는 전체 과정을 아래와 같이 진행.

## 1️⃣ 프로젝트 생성

#### CMD(명령 프롬프트)를 열고, 프로젝트를 생성할 워크스페이스 디렉토리(`C:\WorkspaceExtjs`)로 이동.

```plaintext
C:\>cd WorkspaceExtjs
```
#### 이동한 후, 다음 명령어를 입력하여 ExtJS 프로젝트를 생성. 이 명령어는 c:\senchasdk에 위치한 Sencha SDK를 사용해 ExFrm이라는 이름의 ExtJS 애플리케이션을 현재 워크스페이스에 생성.

```plaintext
C:\WorkspaceExtjs>sencha -sdk c:\senchasdk generate app ExFrm ./ExFrm
```
###### 이제 ExFrm 폴더 안에 새로운 ExtJS 프로젝트가 생성됨.

## 2️⃣ 개발 모드로 빌드
##### 프로젝트가 생성되면, 생성된 프로젝트 디렉토리(C:\WorkspaceExtjs\ExFrm)로 이동.

```plaintext
C:\WorkspaceExtjs>cd ExFrm
```
##### 프로젝트 디렉토리에 위치한 상태에서, 아래 명령어를 사용하여 프로젝트를 개발 모드(`development`)로 빌드.

```plaintext
C:\WorkspaceExtjs\ExFrm>sencha app build development
```
##### 개발 모드로 빌드하는 이유는 개발 중에 빠른 테스트와 디버깅을 용이하게 하기 위함. 빌드 과정이 완료되면, 프로젝트의 build 폴더 내에 개발용 파일들이 생성.

## 3️⃣ Tomcat 서버의 root에 복사
#### 빌드된 프로젝트를 `Tomcat` 서버의 `root`디렉토리에 배포하기 위해, 빌드 결과물을 `Tomcat` 설치 폴더 내의 `webapps\ROOT` 디렉토리로 복사. 


#### 복사한 파일과 폴더를 Tomcat 설치 폴더 내의 webapps\ROOT 디렉토리에 붙여넣자.
#### 이제 Tomcat 서버를 시작하거나 재시작하면, 브라우저를 통해 http://localhost:8080 주소로 접속했을 때 새로 생성한 ExtJS 애플리케이션을 볼 수 있음.

##### 이 과정을 통해 ExtJS 프로젝트의 생성부터 빌드, 그리고 배포까지의 전체적인 흐름을 이해할 수 있음.
---
# ExtJS 애플리케이션의 기본 구조 설정하기 🏗️

ExtJS 프레임워크를 사용하여 웹 애플리케이션을 구축할 때, 체계적인 폴더 구조와 명확한 컴포넌트 정의가 중요합니다. 여기서는 `view` 폴더 내에 `cust`와 `admin` 폴더를 생성하고, 애플리케이션의 메인 페이지를 설정하는 과정을 단계별로 설명합니다.

## 1. 폴더 구조 생성하기 📁

#### `view` 폴더 내에 `cust`와 `admin` 두 개의 서브 폴더를 생성. 이렇게 분리하여 폴더를 구성함으로써, 애플리케이션의 다양한 기능 영역(예: 고객 관리, 관리자 기능 등)을 명확하게 구분할 수 있다.

- ####  **cust 폴더**: 고객 관련 뷰를 담당하는 컴포넌트들을 저장.
- #### **admin 폴더**: 관리자 기능 관련 뷰를 담당하는 컴포넌트들을 저장.

## 2. Alias 설정하기 🔖

#### 각 컴포넌트의 `alias`는 고유한 이름을 사용하여 충돌을 방지하도록하자. 보통 `alias`는 패키지 경로를 포함하지만, 간단하게 호출하기 위해 `main`과 같은 간단한 이름을 사용할 수 있다.

## 3. 메인 페이지 컴포넌트 정의하기 🌟

#### 애플리케이션의 시작 페이지는 `main`이며, 다음은 `ExFrm.view.main.Main` 컴포넌트의 정의.

```javascript
Ext.define('ExFrm.view.main.Main', {
    extend: 'Ext.container.Container', // 컨테이너 확장
    xtype: 'main', // xtype을 'main'으로 설정

    requires: [ // 필요한 의존성 명시
        'Ext.plugin.Viewport',
        'Ext.window.MessageBox',
        'ExFrm.view.main.MainController',
        'ExFrm.view.main.MainModel',
        'ExFrm.view.main.List',
        'ExFrm.view.menu.LeftMenu'
    ],

    controller: 'main', // 컨트롤러 지정
    viewModel: 'main', // 뷰모델 지정
    layout: 'border', // 레이아웃을 'border'로 설정

    items: [{ // 메인 페이지 구성 요소
        region: 'north', // 상단 영역
        height: 50,
        bodyStyle: 'background-color:black',
        html: '<h2><font color="white">&nbsp;&nbsp;타이틀</font></h2>'
    }, {
        region: 'west', // 왼쪽 메뉴 영역
        width: 200,
        xtype: 'leftmenu', // 사용자 정의 메뉴 컴포넌트
    }, {
        region: 'center', // 중앙 탭 패널 영역
        xtype: 'tabpanel',
        name: 'mainbar',
        items: [{ // 탭 내용
            title: '화면1',
            xtype: 'panel',
        }]
    }]
});
```
#### 이 구조를 통해, 메인 페이지에는 상단 타이틀 바, 왼쪽 메뉴, 그리고 중앙의 탭 패널이 포함되고. 왼쪽 메뉴(leftmenu)는 사용자 정의 컴포넌트로, 메뉴 아이템 클릭 시 관련 화면을 중앙 탭 패널에 로드할 수 있다.
#### 이 과정을 통해 애플리케이션의 기본적인 구조와 메인 페이지를 설정할 수 있고. 각 컴포넌트는 명확한 역할을 가지며, 이를 통해 사용자에게 효율적인 인터페이스를 제공함. 🛠️

# ExtJS 애플리케이션의 메인 페이지 추가 설명란 🌐
```javascript
Ext.define('ExFrm.view.main.Main', {
```
### 📝 Ext.define: ExtJS에서 클래스를 정의하는 메서드. ExFrm.view.main.Main는 이 클래스의 고유한 이름이며, 애플리케이션의 구조에서 중요한 위치를 차지.

```javascript
    extend: 'Ext.container.Container',
```
### 🔍 extend: 이 클래스가 확장(상속)할 부모 클래스를 지정. Ext.container.Container는 다양한 컴포넌트를 담을 수 있는 범용 컨테이너.

```javascript
    xtype: 'main',
```
### ✨ xtype: 컴포넌트의 별칭. xtype: 'main'을 통해 나중에 레이아웃 정의 시 이 컨테이너를 쉽게 참조할 수 있음.

```javascript

    requires: [
        ...
    ],
```
### 🛠️ requires: 클래스가 동작하기 위해 필요한 다른 클래스들(컨트롤러, 뷰모델, 추가 뷰 등)을 명시. 이는 의존성 관리에 중요.

```javascript
    controller: 'main',
    viewModel: 'main',
```
### 🎮 `controller`와 `viewModel`: `MVC` 또는 `MVVM` 아키텍처를 구현하는 데 중요한 부분. 각각 컨트롤러와 뷰모델의 인스턴스를 지정.

```javascript
    layout: 'border',
```
### 🖼️ layout: 컨테이너 내부의 컴포넌트 배치 방식을 정의. border 레이아웃은 컨테이너를 여러 영역으로 나누어 관리.

```javascript

    items: [
        ...
    ]
});
```
### 📦 items: 이 컨테이너에 포함될 자식 컴포넌트들을 정의. 각각 `region` 속성을 사용해 상단(`north`), 왼쪽(`west`), 중앙(`center`) 영역에 배치.

### HTML 엔티티`&nbsp;` 설명
#### `&nbsp;`는 HTML에서 공백(`Non-Breaking SPace`)을 나타내는 엔티티. 여러 개의 공백을 웹 페이지에 표시하고 싶을 때 사용하며, 일반적인 공백 문자와 달리 줄 바꿈에서도 분리되지 않음. 예제 코드에서는 `&nbsp;&nbsp;`를 사용하여 타이틀 앞에 고정된 공백 두 개를 추가.
---

## ExtJS 애플리케이션의 구조 및 흐름 이해하기 🌟

### ExtJS를 사용하여 복잡한 웹 애플리케이션을 구축하는 과정은 명확한 구조와 아키텍처를 필요로 합니다. 이번 세션에서는 메인 페이지의 구성, 서쪽 영역에 메뉴를 배치하는 방법, 그리고 이 메뉴가 어떻게 사용자의 클릭에 반응하는지를 살펴보자.

## 1. 애플리케이션의 메인 화면 설정 🏠

### 시작점: `app.js`

- **메인 뷰 설정**: 애플리케이션의 시작 파일인 `app.js`에서 `mainView`를 `'ExFrm.view.main.Main'`로 지정. 이는 애플리케이션을 시작할 때 자동으로 메인 화면을 생성.

### 메인 화면 정의: `Main.js`

```javascript
Ext.define('ExFrm.view.main.Main', {
    extend: 'Ext.container.Container',
    xtype: 'main',
    items: [{
        region: 'west',
        width: 200,
        xtype: 'leftmenu',
        html: '메뉴',
    }, ...]
});
```
### 레이아웃 구성: 메인 화면은 border 레이아웃을 사용하여 화면을 여러 영역으로 분리. 특히 region: 'west'는 서쪽 영역에 메뉴를 배치하는 데 사용됨.

## 2. 메뉴 컴포넌트 구성 📁
#### 메뉴 정의: LeftMenu.js
```javascript

Ext.define('ExFrm.view.menu.LeftMenu', {
    extend: 'Ext.tree.TreePanel',
    alias: 'widget.leftmenu',
    requires: ['ExFrm.view.menu.LeftMenuController'],
    controller: 'leftmenu',
    store: {
        type: 'tree',
        fields: ['name', 'url'],
        proxy: {
            type: 'ajax',
            url: './service/menu.json'
        },
        autoLoad: true
    }
});
```
#### 트리 패널 상속: 메뉴는 Ext.tree.TreePanel을 상속받아 구성됨. 트리 구조를 통해 계층적인 메뉴를 쉽게 구현할 수 있음.

#### 데이터 스토어: 메뉴의 항목은 menu.json 파일에서 로드. 이 파일은 메뉴 항목의 이름과 URL을 정의하고 있음 (임시로).

### 메뉴 컨트롤러: LeftMenuController.js
```javascript
Ext.define('ExFrm.view.menu.LeftMenuController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.leftmenu',
    onMenuClick: function(obj, selItem) {
        Ext.Msg.alert('선택', selItem.data.url);
    }
});
```
#### 이벤트 처리: 사용자가 메뉴 항목을 클릭하면, onMenuClick 메서드가 호출됨. 이 메서드는 클릭된 메뉴 항목에 연결된 URL을 보여주는 알림을 표시함.
### 3. 메뉴 데이터 구성 🌲
#### 데이터 파일: `menu.json`
```json
Copy code
{
    "children": [
        {"name": "화면1", "url": " ", "leaf": false, "children": [...]},
        {"name": "화면2", "url": " ", "leaf": false}
    ]
}
```
#### 트리 구조: 메뉴는 계층적으로 구성. 각 메뉴 항목(화면1, 화면2)은 하위 메뉴 항목을 가질 수 있으며, 이는 children 배열을 통해 정의됨.
### 요약
#### `ExtJS`에서 애플리케이션의 메인 화면을 구성하고, 메뉴 시스템을 통해 사용자 인터랙션을 처리하는 과정은 위와 같고. 메뉴 컴포넌트는 트리 구조를 사용하여 계층적인 메뉴를 구성하며, 각 메뉴 항목에 대한 사용자의 클릭 이벤트는 `LeftMenuController`를 통해 처리됨. 이 과정은 MVVM 아키텍처의 화면단 구현에 맞추어져 있으며, 후속 작업으로 MVC 패턴과의 연동을 통해 배워보자.
---

# 🌈 MVC + MVVM 아키텍처의 혼합 사용에 대한 이해 II 🌟

## ExtJS에서 글로벌 컨트롤러 설정하기 🌐

### 단계별 가이드

#### 1. 기본 파일 준비하기

- ####  **`MVVMAPP` 폴더**에서 `Main.js`, `MainController.js`, `MainModel.js` 파일을 복사.
- #### **`Tomcat root` 폴더** 안에 **`admin` 폴더**를 만들고, 복사한 세 파일을 여기에 붙여넣고.
- #### 복사한 파일들의 이름을 `Test.js`, `TestController.js`, `TestModel.js`로 변경.
- #### 각 파일 내의 클래스명도 각각 `Test`, `TestController`, `TestModel`로 수정.
- #### 폴더 이름도 test로 변경
- 

#### 2. 메뉴 JSON 파일 수정하기

- #### 프로젝트의 `menu.json` 파일을 열고, 테스트 화면을 호출하고자 하는 메뉴 아이템의 `"url"` 속성을 `"ExFrm.view.test.Test"`로 변경.
```json
{
    "name": "Test화면호출",
    "url": "ExFrm.view.test.Test",
    "leaf": true
}
```
## 🛠 글로벌 컨트롤러 추가하기

### 단계 1: 컨트롤러 폴더 생성
- **애플리케이션의 `app` 폴더** 내에 **`controller` 폴더**를 생성.
  - 이 폴더는 애플리케이션 내 모든 컨트롤러 파일을 관리하는 곳.

### 단계 2: `AppController.js` 파일 생성
- **`AppController.js`** 라는 새 파일을 생성.
  - 이 파일은 애플리케이션 전반에 걸쳐 공통으로 사용될 로직을 담당하는 글로벌 컨트롤러.

### 단계 3: `AppController` 구현
- 생성한 `AppController.js` 파일 안에, 글로벌 컨트롤러로서의 로직을 구현.
  - 예: 이벤트 핸들링, 상태 관리, 다른 뷰와의 데이터 교환 등
---

### 📝 단계 4: `Application.js`에서 글로벌 컨트롤러 등록하기

### `controllers` (복수형)
- ##### 애플리케이션의 설정 파일인 **`Application.js`**를 열고, `AppController`를 컨트롤러 배열에 등록.
- **예시:** 
```javascript
    Ext.define('ExFrm.Application', {
        extend: 'Ext.app.Application',
        name: 'ExFrm',
        controllers: ['AppController'],
    });
```
- **설명:** 이 속성을 사용하면, `Application` 클래스 내에서 여러 컨트롤러를 등록할 수 있으며, 이 컨트롤러들은 애플리케이션의 다양한 부분에서 접근 및 사용될 수 있다.
### `controller` (단수형)
- **용도:** 특정 뷰에 대한 `ViewController`를 지정.

- **예시:**
```javascript
    Ext.define('MyApp.view.Main', {
        extend: 'Ext.panel.Panel',
        xtype: 'main',
        controller: 'main',  // 뷰에 ViewController를 연결합니다.
        // 뷰의 구성요소 및 로직 구현...
    });
```
- #### **설명:** 각 뷰는 `controller` 속성을 사용하여 자신만의 이벤트 처리 및 로직을 관리하는 `ViewController`를 지정할 수 있고. 주로 해당 뷰 내에서 발생하는 이벤트를 처리하는 데 사용된다.

#### 이러한 방식으로 ExtJS 애플리케이션 내에서 `controllers`와 `controller` 속성을 적절히 활용함으로써, 애플리케이션의 로직과 이벤트 처리를 효과적으로 관리할 수 있다.
#### 여기서 단수형의 `controller`: `'main'` 예시는 뷰(`MyApp.view.Main`)가 자신의 `ViewController`(`main`)와 연결되어 있음을 의미. 이 연결을 통해 해당 뷰의 동작과 이벤트 핸들링 로직을 `main` 컨트롤러 내에서 정의하고 관리할 수 있게 됨.

```javascript
// 애플리케이션의 메인 컨트롤러 정의
Ext.define('ExFrm.controller.AppController',{
    extend:'Ext.app.Controller', // ExtJS의 컨트롤러 클래스 상속

    // 컨트롤러 설정
    config:{
        // 컴포넌트 참조 설정
        refs:{
            // 'mainBar'라는 이름으로 메인 탭 패널 컴포넌트를 참조
            // 이를 통해 해당 컴포넌트에 쉽게 접근할 수 있음
            mainBar:'main tabpanel[name=mainbar]'
        },
    },
    // 새로운 탭을 메인 탭 패널에 추가하거나, 이미 존재하는 탭을 활성화하는 함수
    setMainBar:function(url, title){
        // refs를 통해 찾은 'mainBar' (즉, 메인 탭 패널)을 가져옴
        let mainBar = this.getMainBar();

        // 선택된 타이틀이 이미 탭에 있는지 확인하기 위한 변수
        var findTitle = false;

        // 메인 탭 패널의 모든 탭을 순회
        for(i=0; i < mainBar.getTabBar().items.items.length; i++){
            console.log('find!!!'); // 디버깅 메시지 출력
            // 순회 중인 탭의 타이틀이 선택된 타이틀과 일치하는지 확인
            if(title == mainBar.getTabBar().items.items[i].title){
                // 일치하는 타이틀이 있으면 해당 탭을 활성화하고 반복 중단
                mainBar.setActiveTab(i);
                findTitle = true;
                break;
            }
        }

        // 일치하는 타이틀을 찾지 못한 경우, 새 탭을 추가
        if(findTitle == false){
            // 주어진 URL로부터 새로운 패널 생성
            var panel = Ext.create(url,{
                autoShow:true, // 생성 즉시 표시
                title:title, // 탭의 제목 설정
                closable: true, // 탭을 닫을 수 있게 설정
                autoDestroy:true // 탭이 닫힐 때 자동으로 제거되도록 설정
            });
            // 생성된 패널을 메인 탭 패널에 추가
            mainBar.add(panel);
            // 방금 추가된 패널을 활성화
            mainBar.setActiveTab(panel);
        }
    }
})
```

## 🚀 ExtJS AppController 상세 안내
### 1. 컨트롤러 정의 및 상속 🧬
```javascript
`Ext.define('ExFrm.controller.AppController', {...})`: 애플리케이션의 글로벌 컨트롤러를 정의.
```
#### `extend: 'Ext.app.Controller'`: ExtJS의 기본 컨트롤러 클래스를 상속받아 기능을 확장.
1. 컨트롤러 설정 🔧
```javascript
- `config`: 컨트롤러의 설정을 담는 객체.
  - `refs`: 컴포넌트 참조를 설정하여 컨트롤러 내에서 쉽게 해당 컴포넌트에 접근할 수 있게 함.
    - `mainBar: 'main tabpanel[name=mainbar]'`: 메인 탭 패널을 `mainBar`로 참조.
```
### 1. 탭 관리 기능 📑
- #### `setMainBar(url, title)`: 새로운 탭을 메인 탭 패널에 추가하거나, 기존의 탭을 활성화하는 함수.
  - #### `let mainBar = this.getMainBar()`: `refs`를 통해 메인 탭 패널 객체를 가져옴.
  - #### 탭 순회 및 확인: 메인 탭 패널의 모든 탭을 순회하며, 주어진 `title`과 일치하는 탭이 있는지 확인.
  - #### 새 탭 추가: 일치하는 탭이 없는 경우, 주어진 `url`로부터 새로운 패널을 생성하고 메인 탭 패널에 추가한 후 활성화.
#### 요약 📌
#### `AppController`는 애플리케이션의 탭 관리 로직을 중앙에서 처리할 수 있게 해주는 강력한 도구
---
## ExtJS 애플리케이션에서 동적 탭 관리 예시

#### 메뉴 컴포넌트를 정의하고, 트리 패널을 상속받아 메뉴 아이템을 트리 구조로 표현합. `store`는 메뉴 데이터를 관리하며, AJAX를 통해 `menu.json`에서 데이터를 불러옴.
```json
{
    "children":[
        {"name": "화면1", "url":" ", "leaf":false,
            "children":[
                {"name":"Test화면호출", "url":"ExFrm.view.test.Test","leaf":true},
                {"name":"화면1-2", "url":"ExFrm.view.cust.CustInfo","leaf":true},
                {"name":"화면1-3", "url":"ExFrm.view.cust.CustInfo","leaf":true}
            ]
        },
        {"name": "화면2", "url":" ", "leaf":false}
    ]
}
```
### 1. 메뉴 구성 (`LeftMenu.js`)

```javascript
Ext.define('ExFrm.view.menu.LeftMenu', {
    extend: 'Ext.tree.TreePanel',
    alias: 'widget.leftmenu',
    requires: ['ExFrm.view.menu.LeftMenuController'],
    controller: 'leftmenu',
    width: 200,
    title: '메뉴',
    rootVisible: false,
    displayField: 'name',
    store: {
        type: 'tree',
        fields: ['name', 'url'],
        proxy: {
            type: 'ajax',
            url: './service/menu.json',
            reader: {
                type: 'json'
            }
        },
        autoLoad: true
    },
    listeners: {
        itemclick: 'onMenuClick'
    }
});
```
### 2. 메뉴 아이템 선택 이벤트 처리 (`LeftMenuController.js`)
#### 사용자가 메뉴 아이템을 클릭하면, LeftMenuController에서 onMenuClick 이벤트가 처리. 이때, `AppController`의 `setMainBar` 메소드를 호출하여, 선택된 메뉴에 해당하는 뷰를 메인 탭 패널에 추가하거나 활성화.
```javascript
Ext.define('ExFrm.view.menu.LeftMenuController',{
    extend:'Ext.app.ViewController',
    alias:'controller.leftmenu',
    onMenuClick:function(obj, selItem){
        Ext.Msg.alert('선택',selItem.data.url);
    let appController =  ExFrm.app.getController('AppController');
    appController.setMainBar(selItem.data.url, selItem.data.name);    
    }
```
### 3. 탭 추가 또는 활성화 (`AppController.js`)
##### `AppController`에서는 메인 탭 패널(`mainBar`)에 새로운 탭을 추가하거나, 이미 존재하는 탭을 활성화하는 `setMainBar` 메소드를 정의합니다. 새 탭이 필요한 경우, 주어진 URL로부터 뷰를 생성하고, 메인 탭 패널에 추가한 후 활성화 (위에 코드 있음 간략 설명).
```json
{"name":"Test화면호출", "url":"ExFrm.view.test.Test","leaf":true} // 이 url 
```
```javascript
Ext.define('ExFrm.view.menu.LeftMenuController',{
    extend:'Ext.app.ViewController',
    alias:'controller.leftmenu',
    onMenuClick:function(obj, selItem){
        Ext.Msg.alert('선택',selItem.data.url);
    let appController =  ExFrm.app.getController('AppController');
    appController.setMainBar(selItem.data.url, selItem.data.name);
    
    // 여기서 클릭을하면 저 url 과 name이  전달된다 
    }

})

 setMainBar:function(url, title) // 전달된 url 과 name 이 타이틀로 가게되며

 // 새로운 탭을 메인 탭 패널에 추가하거나, 이미 존재하는 탭을 활성화하는 함수
    setMainBar:function(url, title){
        // refs를 통해 찾은 'mainBar' (즉, 메인 탭 패널)을 가져옴
        let mainBar = this.getMainBar();

        // 선택된 타이틀이 이미 탭에 있는지 확인하기 위한 변수
        var findTitle = false;

        // 메인 탭 패널의 모든 탭을 순회
        for(i=0; i < mainBar.getTabBar().items.items.length; i++){
            console.log('find!!!'); // 디버깅 메시지 출력
            // 순회 중인 탭의 타이틀이 선택된 타이틀과 일치하는지 확인
            if(title == mainBar.getTabBar().items.items[i].title){
                // 일치하는 타이틀이 있으면 해당 탭을 활성화하고 반복 중단
                mainBar.setActiveTab(i);
                findTitle = true;
                break;
                // 여기서 타이틀 중복 새탭 추가되는 것을 막아주고
            }
        }
        // 일치하는 타이틀을 찾지 못한 경우, 새 탭을 추가
        if(findTitle == false){
            // 주어진 URL로부터 새로운 패널 생성
            var panel = Ext.create(url,{
                autoShow:true, // 생성 즉시 표시
                title:title, // 탭의 제목 설정
                closable: true, // 탭을 닫을 수 있게 설정
                autoDestroy:true // 탭이 닫힐 때 자동으로 제거되도록 설정
            });
            // 생성된 패널을 메인 탭 패널에 추가
            mainBar.add(panel);
            // 방금 추가된 패널을 활성화
            mainBar.setActiveTab(panel);
        }
        // 이 url 의 해당하는 클래스가 없으면 생성하여 Test.js 의 panel을 화면에 뿌린다
        Ext.define('ExFrm.view.test.Test', {
    extend: 'Ext.panel.Panel',
    requires:['ExFrm.view.test.TestController', 
            'ExFrm.view.test.TestModel'],
    controller:'test',
    viewModel:{
        type:'test'
    },
    xtype: 'test',
    //alias: 'widget.main',
    title:'MVVC 아키텍쳐',
    layout:{
        type:'vbox',
        align:'stretch'
    },
    bodyPadding:'10 10 10 10',
    closable:true,
    items:[{
        xtype:'textfield',
        fieldLabel:'제목' ,
        name:'subject1',
        reference:'subject1'
    },{
        xtype:'button',
        text:'전달',
        //name:'btnSend',
        handler:'onSendClick'
    },{
        xtype:'textfield',
        fieldLabel:'전달받은제목' ,
        name:'subject2',
        reference:'subject2'
    },{
        xtype:'grid',
        flex:1,
        //store:'Personnel',
        bind:{
            store:'{personalInfo}'
        },
        columns:[{
            text:'이름',
            dataIndex:'name',
            with:100
        },{
            text:'이메일',
            dataIndex:'email',
            flex:1
        },{
            text:'전화번호',
            dataIndex:'phone',
            flex:1
        }]
    }]

});
// 이구조의 화면을 새롭게 추가하는것이라고 보면된다 ..
```

### 단계 4: Test 뷰의 렌더링 🎨
#### Test 뷰는 사용자에게 표시될 UI 컴포넌트 및 레이아웃을 정의. 또한, `TestController` 및 `TestModel`을 사용하여 UI 로직 및 데이터 관리를 수행
---
# 🌟 Ext JS 서버 연동 (Ext.Ajax) 🌈

## 📄 서버와 연동하기 위한 데이터 포맷

```json
{
    "success": true/false, // 🌟 통신 성공 여부
    "data": { // 💾 실제 데이터
        "custInfo": {},
        "list": []
    },
    "msg": "" // 🚨 서버 에러 메시지
}
```
- #### `success`: 요청이 성공적으로 처리되었는지 실패했는지를 나타내는 부울 값. 통신의 성공 여부를 알려줌.
- #### `data`: 서버에서 반환된 실제 데이터를 포함. 객체나 배열 등 다양한 형태로 구성될 수 있음.
- #### `msg`: 에러가 발생했을 때 서버에서 전송하는 메시지. 사용자에게 보여줄 수 있는 에러 메시지나 디버깅에 도움이 되는 정보를 포함할 수 있음.
- 
## 🌟 Ext JS에서 서버와 연동하는 방법
#### 1. Ext.Ajax 사용하기

#### Ext.Ajax는 Ext JS에서 제공하는 AJAX 통신 기능. 서버에 데이터를 요청하고 응답을 받는 데 사용됨.

```javascript
Ext.Ajax.request({
    url: 'service/ajax.json', // 서버 URL
    success: function(response) {
        var data = Ext.decode(response.responseText);
        console.log('서버 응답:', data);
    },
    failure: function() {
        console.log('서버 요청 실패');
    }
});
```
### 2. Store에 Proxy 이용하기
#### Store는 데이터를 관리하는 컴포넌트. proxy를 통해 서버와의 연동을 설정할 수 있으며, 이는 데이터 소스와의 상호 작용 방식을 정의.

```javascript
Ext.create('Ext.data.Store', {
    model: 'MyApp.model.MyModel',
    proxy: {
        type: 'ajax',
        url: 'service/data.json',
        reader: {
            type: 'json',
            rootProperty: 'data'
        }
    }
});
```
### 3. Form을 이용한 방법
#### Ext JS의 Form 컴포넌트를 사용하여 서버에 데이터를 전송할 수 있음. submit 메소드를 사용하여 폼 데이터를 서버로 전송.

```javascript
myForm.getForm().submit({
    url: 'service/formSubmit',
    success: function(form, action) {
       console.log('성공:', action.result.msg);
    },
    failure: function(form, action) {
        console.log('실패:', action.result.msg);
    }
});
```
### 📁 실습: ajax.json 파일 생성

#### 서버와의 연동을 테스트하기 위해 `service` 폴더에 `ajax.json` 파일을 생성.

```json
{
    "success": true,
    "data": {
        "personnelInfo": {
            "name": "Jean Luc",
            "email": "jeanluc.picard@enterprise.com",
            "phone": "555-111-1111"
        }
    },
    "msg": ""
}
```
#### 이 파일은 서버에서 데이터를 요청했을 때 응답으로 사용될 수 있다. Ext.Ajax.request를 사용하여 이 파일을 요청하고, 서버에서 반환된 데이터를 콘솔에 출력해 보는 실습을 진행해 보자.

```javascript
Ext.define('ExFrm.view.test.AjaxTestController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.ajaxtest',
    onSendClick: function() {
        var me = this;
        Ext.Ajax.request({
            url: './service/ajax.json',
            params: {
                // 필요한 경우 여기에 요청 파라미터를 추가.
            },
            scope: this,
            success: function(res) {
                var resObj = Ext.JSON.decode(res.responseText); // 응답 텍스트를 JSON 객체로 변환
                if (resObj.success) {
                    var data = resObj.data.personnelInfo;
                    console.log("data =", data); // 콘솔에 데이터 출력
                    // ViewModel의 personalInfo 스토어에 데이터 추가
                    this.getViewModel().getStore('personalInfo').add(data);
                } else {
                    // 실패 처리 로직
                }
            },
            failure: function() {
                console.log('서버 요청 실패');
            }
        });
    }
});
```
### 📝 응답 데이터 처리하기
#### 서버로부터 받은 응답은 문자열 형태의 `JSON`이므로, 이를 애플리케이션에서 사용하기 위해서는 객체로 변환해야 함. `Ext.JSON.decode` 메소드를 사용하여 `JSON`문자열을 `JavaScript` 객체로 변환.

```javascript
let resObj = Ext.JSON.decode(res.responseText); // JSON 문자열을 객체로 변환
```
#### 변환된 객체에서 필요한 데이터를 추출하여 사용. 예를 들어, `personnelInfo`에 접근하려면 다음과 같이 해보자.

```javascript
let data = resObj.data.personnelInfo;
```

### 💡 JSON 객체 다루기
#### 객체로 변환하기: `Ext.JSON.decode` 메소드를 사용하여 `JSON` 문자열을 `JavaScript` 객체로 변환할 수 있음.
#### 문자열로 변환하기: `JavaScript` 객체를 다시 `JSON` 문자열로 변환하려면 `JSON.stringify()` 메소드를 사용.

### 🔄 실습: ajax.json 파일 사용하기
#### `ajax.json` 파일에는 테스트용 데이터가 `JSON` 형식으로 저장되어 있다. 이 파일을 서버로부터 요청하여 응답 데이터를 애플리케이션에 사용하는 방법을 실습.
```json
{
    "success": true,
    "data": {
        "personnelInfo": {
            "name": "AJAX",
            "email": "jeanluc.picard@enterprise.com",
            "phone": "555-111-1111"
        }
    },
    "msg": ""
}
```
## 🌟 Ext.Ajax.request와 this의 스코프
### 🎯 this의 스코프 관리
#### `this`는 현재 실행 중인 컨텍스트를 가리키는 지시자. `Ext JS`의 `Ext.Ajax.request`에서는 `this`를 특별히 관리해주어야 함.

```javascript
Ext.define('ExFrm.view.test.AjaxTestController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.ajaxtest',
    onSendClick: function() {
        var me = this; // 👈 `this`를 적절히 관리하기 위한 변수
        Ext.Ajax.request({
            url: './service/ajax.json',
            params: {},
            scope: me, // 👈 AJAX 콜백 내부에서 `this`를 ViewController로 설정
            success: function(res) {
                // 성공 처리 로직
            },
            failure: function() {
                // 실패 처리 로직
            }
        });
    }
});
```
#### `scope`: `this` 설정으로 콜백 함수 내부에서 `this`가 `ViewController`를 가리키게 함. 이로써 컨트롤러의 메소드나 속성에 쉽게 접근할 수 있음.
### 🚀 success 콜백 함수
#### `Ext.Ajax.request`의 `success` 콜백은 서버 응답 코드가 200번대일 때 호출됨. 하지만, 이는 데이터 처리가 성공적이었는지의 여부와는 별개.
#### 서버에서 반환된 실제 데이터의 성공 여부(`resObj.success`)는 응답 내용(`res.responseText`)을 분석하여 확인.
```javascript
success: function(res) {
    var resObj = Ext.JSON.decode(res.responseText); // 응답을 객체로 변환
    if (resObj.success) {
        // 데이터 처리 성공 로직
    } else {
        // 데이터 처리 실패 로직
    }
},
```
### 📌 실패 처리
- #### `failure` 콜백은 요청 자체가 실패했을 때 호출. 예를 들어 네트워크 문제나 서버 오류(500번대 응답 코드) 등.
### 🛠️ Ext.Ajax.request vs. 스토어 사용
- #### 스토어와 프록시 📚: `Grid`나 `ComboBox`와 같은 컴포넌트에서는 데이터를 관리하기 위해 스토어`(Store)`를 사용. 스토어는 데이터 로딩, 필터링, 정렬 등의 작업을 쉽게 만들어주며, 프록시`(Proxy)`를 통해 서버와의 데이터 교환을 처리.
- #### 단일 데이터 요청 📡: `Ext.Ajax.request`는 주로 단건 조회나 특정 데이터를 서버로부터 요청할 때 사용. 단일 정보나 간단한 객체를 처리할 때 유용.
- #### 폼 데이터 전송 📤: 데이터를 서버로 전송할 때는 `Form` 컴포넌트와 함께 `submit` 메소드를 사용. 이 방법은 주로 사용자 입력을 처리하여 서버에 데이터를 전송할 때 적합함.

### 📖 요약
#### Ext JS에서 서버와의 통신을 위해 `Ext.Ajax.request`를 사용할 때는 `scope` 옵션으로` this`의 스코프를 적절히 관리. `success` 콜백은 `HTTP` 응답 코드가 200번대일 때 호출되며, 응답 데이터의 성공 여부는 별도로 확인. Ext JS에서 데이터 처리 방식은 사용하는 컴포넌트나 요구 사항에 따라 다르므로, 상황에 맞게 적절한 방법을 선택하는 것이 중요.

### 🚀 This , Scope

```javascript
let me = this; // 'this'를 'me'에 할당하여 현재 컨트롤러의 참조를 보존.
```
### 📌 scope를 사용하지 않았을 때의 this
#### 위의 예제에서 `success` 콜백 함수 내에서 `let me = this;`를 사용하고 있다. 이는 `Ext.Ajax.request` 호출 시 `scope` 옵션을 명시적으로 지정하지 않았기 때문에 콜백 함수 내의 `this`가 전역 객체`(window 객체)`를 가리킬 가능성이 있어, 안전하게 현재 컨트롤러의 참조를 me 변수에 저장하는 방법을 사용하고 있음.

### ✅ scope를 사용했을 때의 this
#### `scope` 옵션을 사용하면 `success, failure`와 같은 콜백 함수 내부에서 `this`가 가리키는 객체를 명시적으로 설정할 수 있다. 아래의 코드는 `scope` 옵션을 추가하여 `this`가 항상 `AjaxTestController` 인스턴스를 가리키도록 하는 방법을 보여줌.

```javascript
Ext.Ajax.request({
    url: './service/ajax.json',
    params: {},
    scope: this, // 'this'는 AjaxTestController 인스턴스를 가리킨다.
    success: function(res) {
        // 이제 여기서 'this'는 'AjaxTestController' 인스턴스.
    },
    failure: function(res) {
        // 여기서도 'this'는 'AjaxTestController' 인스턴스.
    }🎯 요약
    
});
```
### 이렇게 `scope: this`를 지정함으로써, 콜백 함수 내에서 `this.getViewModel().getStore('personalInfo').add(data);`와 같이 현재 컨트롤러의 메소드와 속성에 안전하게 접근할 수 있게 됨.

### 🎯 요약
#### `scope` 옵션을 설정하지 않았을 때, 콜백 함수 내부에서 `this`는 예상과 다르게 전역 객체`(window)`를 가리킬 수 있음. 이는 의도치 않은 버그를 초래할 위험이 있다.
#### `scope` 옵션을 사용하여`this`의 컨텍스트를 명시적으로 설정하면, 콜백 함수 내에서 `this`가 항상 기대하는 컨트롤러 인스턴스를 가리키도록 할 수 있어, 코드의 안정성과 가독성이 향상됨.
#### 비전공자 또는 초보 개발자도 이해할 수 있도록 `this`의 스코프와 관련된 문제를 명확하게 인식하고, `scope` 옵션을 적절히 사용하는 방법을 습득하는 것이 중요하다.
---
# 🌈 서버연동 (Store) 사용 🎯

## 🌟 Ext JS 스토어와 그리드 바인딩 이해하기
#### `Ext JS`에서 스토어(`Store`)는 데이터를 관리하고, 그 데이터를 화면에 표시하는 컴포넌트(예: `grid`)와 연결될 수 있음. 스토어에 있는 데이터가 변경되면, 그 변경사항이 자동으로 해당 컴포넌트에 반영됨. 이를 통해 데이터와 UI 간의 동기화를 쉽게 관리할 수 있음.

### 📌 스토어 정의와 바인딩
#### `Store`는 데이터의 집합. 데이터는 정적으로 정의할 수도 있고, 외부 소스에서 동적으로 로드할 수도 있음. 그리드와 같은 UI 컴포넌트는 스토어와 바인딩되어 데이터를 표시.

### 🔹 스토어 예제
```javascript
stores:{
    personalInfo:{
        data:[
            { name: 'Jean Luc', email: "jeanluc.picard@enterprise.com", phone: "555-111-1111" },
            // 더 많은 데이터 항목...
        ],
        // 추가 설정: proxy, reader 등...
    }
}
```
### 🔹 그리드에 스토어 바인딩하기
```javascript
{
    xtype: 'grid',
    bind: {
        store: '{personalInfo}' // ViewModel 내 정의된 스토어를 바인딩
    },
    columns: [
        // 그리드 컬럼 정의
    ]
}
```
### 🚀 스토어 데이터 로딩
#### 스토어에 `proxy`를 설정하면, 외부 데이터 소스로부터 데이터를 로드할 수 있음. proxy의 type에 따라 다양한 종류의 데이터 소스(예: 메모리, AJAX, REST 등)를 사용할 수 있음.

### 🔹 AJAX를 통한 데이터 로드 예제
```javascript
personalInfo:{
    proxy: {
        type: 'ajax',
        url: './service/store.json', // 데이터를 로드할 URL
        reader: {
            type: 'json',
            rootProperty: 'data.list' // 서버 응답에서 실제 데이터가 위치한 경로
        }
    },
    autoLoad: true // 스토어 생성 시 데이터 자동 로드
}
```
### 📖 스토어와 AJAX
#### 스토어는 `autoLoad`: `true` 설정을 통해 자동으로 데이터를 로드할 수 있음. 이는 스토어가 생성될 때 지정된 데이터 소스로부터 데이터를 가져오도록 함.

### 🔹 store.json 예제 데이터
```json
{
    "success":true,
    "data": {
        "list": [
            { "name": "Store1", "email": "store1@example.com", "phone": "555-111-1111" },
            // 더 많은 데이터 항목...
        ]
    },
    "msg":""
}
```
### 🎯 핵심 요소
- #### 스토어(`Store`): 데이터 관리 및 UI 컴포넌트와의 데이터 바인딩을 담당.
- #### 데이터 바인딩: `ViewModel`의 스토어와 `UI` 컴포넌트(예: `grid`)를 연결.
- #### 데이터 로드: proxy 설정을 통해 외부 데이터 소스로부터 데이터를 로드.
- #### 동기화: 스토어의 데이터가 변경되면, 그 변경사항이 바인딩된 UI 컴포넌트에 자동으로 반영.

## 🛠 StoreTestModel.js 수정하기
#### 스토어의 `autoLoad` 속성을 `false`로 설정하여, 스토어가 생성될 때 자동으로 데이터를 로드하지 않도록 해보자. 이는 사용자가 명시적으로 데이터를 요청할 때만 데이터를 로드하고자 할 때 유용.

```javascript
Ext.define('ExFrm.view.test.StoreTestModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.storetest',
    stores:{
        personalInfo:{
            fields:['aaa'], // 데이터 구조를 정의합니다.(명시안해도 의미없다고함)
            proxy:{
                type: 'ajax',
                url: './service/store.json', // 데이터 로드 URL
                reader: {
                    type: 'json',
                    rootProperty: 'data.list' // 서버 응답에서 데이터가 위치한 경로
                }
            },
            autoLoad: false // 스토어 생성 시 자동 로드 비활성화
        }
    }
});
```
### 🔹 StoreTestController 수정하기
#### 스토어를 명시적으로 로드하는 로직을 컨트롤러에 추가. 사용자가 조회 버튼을 클릭하면 `onSendClick` 함수가 호출되고, 이 함수 내에서 스토어의 .load() 메소드를 호출하여 데이터를 로드.

```javascript
Ext.define('ExFrm.view.test.StoreTestController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.storetest',
    onSendClick: function() {
        let me = this;
        me.getViewModel().getStore('personalInfo').load(); // 스토어 로드 호출
    }
});
```
### 📖 데이터 동적 로딩과 표시
- #### 처음에 데이터가 표시되지 않음: `autoLoad`가 `false`로 설정되어 있기 때문에, 스토어가 자동으로 로드되지 않아 초기에는 데이터가 표시되지 않음.
- #### 조회 버튼 클릭 시 데이터 로딩: 사용자가 조회 버튼을 클릭하면, 컨트롤러의 `onSendClick` 메소드가 실행되어 스토어의 데이터가 로드되고, 그 결과가 화면에 반영.
### 🚀 확장성과 응용
- #### 페이징 및 쿼리 처리: 실제 애플리케이션에서는 서버로부터 데이터를 페이징 처리하거나, 특정 조건에 맞는 데이터를 쿼리하기 위해 스토어의 proxy 설정을 활용할 수 있음.
- #### rootProperty 외의 속성 활용: `reader`의 `rootProperty` 외에도 페이징 처리를 위한 `totalProperty`, `start`, `limit` 같은 속성을 활용하여 복잡한 데이터 관리 요구사항을 충족시킬 수 있음.
### 📚 핵심 개념
- #### 스토어(Store): 데이터를 관리하고, UI 컴포넌트와 바인딩하여 동적인 데이터 표시를 가능하게 함.
- #### 동적 데이터 로딩: 사용자의 액션에 의해 데이터를 로드하여 애플리케이션의 반응성을 높일 수 있음.
- #### 데이터 관리와 표시의 분리: 데이터 로딩 로직을 `ViewModel`과 `Controller`에 정의함으로써, MVC/MVVM 패턴의 원칙에 따라 데이터 관리와 UI 로직을 분리.

## 🌟 스토어 데이터 로딩 기본
#### Ext JS에서 스토어(`Store`)는 애플리케이션의 데이터를 관리. 사용자의 특정 액션에 따라 필요한 데이터를 서버로부터 가져오는 역할을 함.

#### 🚀 데이터 로드를 위한 파라미터 설정
#### 사용자 입력 받기: 사용자가 입력하는 정보를 파라미터로 서버에 전송할 수 있음. 예를 들어, 특정 주제(`subject1`)에 대한 정보를 검색하고 싶을 때, 사용자는 입력 필드에 주제를 입력.

```javascript
let params = {
    subject1: me.lookupReference('subject1').getValue()
};
```
##### 이 코드는 subject1이라는 참조를 가진 입력 필드에서 값을 가져와 params 객체에 저장.

### 🔹 스토어에서 데이터 로드하기
#### 스토어 로드 호출: `params`에 저장된 사용자 입력 정보를 사용하여 스토어의 데이터를 로드.

```javascript
me.getViewModel().getStore('personalInfo').load({
    params: params, // 서버로 전송할 파라미터
    callback: function(records, operation, success) {
        // 데이터 로드 후 실행될 콜백 함수
        Ext.Msg.alert('확인', '콜백함수 실행');
    }
});
```
#### 이 코드는 `personalInfo` 스토어의 `load` 메서드를 호출하면서, `params`로 사용자 입력 정보를 전달하고, 데이터 로드가 완료된 후에는 콜백 함수를 실행.

### 🎯 콜백 함수의 활용
#### 콜백 함수 실행: 데이터 로드가 성공적으로 완료되면, 정의된 콜백 함수가 실행. 이 함수 내에서는 데이터 로드 성공 여부에 따른 추가 작업을 수행할 수 있음.

```javascript
  params: params,
            callback:function(records, operation, success){
                console.log(params)
                Ext.Msg.alert('확인','콜백함수');
            }
```
#### 콜백 함수는 로드된 데이터(`records`), 로드 작업에 대한 정보(`operation`), 그리고 로드 성공 여부(`success`)를 인자로 받습니다. 이를 통해 사용자에게 로드 결과에 대한 피드백을 제공하거나, 필요한 UI 업데이트를 수행할 수 있음.

### 📖 결론
- #### 파라미터(params): 사용자 입력과 같은 추가 정보를 서버로 전송하여 필요한 데이터를 정확히 요청.
- #### 콜백 함수: 데이터 로드가 완료된 후 실행되어, 성공 또는 실패에 따른 적절한 사용자 피드백을 제공하거나, 데이터 처리를 수행.
#####  이러한 과정을 통해, Ext JS 애플리케이션에서 사용자의 요구에 맞는 데이터를 동적으로 로드하고, 로드 결과에 따라 적절한 액션을 취할 수 있고. 이 모든 것이 사용자와의 상호작용을 풍부하게 만들어주며, 애플리케이션의 사용성을 크게 향상시킨다.
---
# 🌈 서버연동 (Form Submit) 사용

## 🌈 Ext JS 폼 제출하기: 기본 개념과 구현
#### Ext JS에서 폼(form) 관리는 Ext.form.Panel을 사용하여 손쉽게 할 수 있다. 이번 섹션에서는 Ext JS의 폼 패널을 사용해 서버로 데이터를 전송하는 과정을 살펴보자.

### 폼 패널 구성하기
#### 폼 패널(`Ext.form.Panel`)은 사용자 입력을 받기 위한 인터페이스를 제공. 다음은 간단한 폼 패널 예제로, 이름, 이메일, 전화번호를 입력받는 세 개의 텍스트 필드를 만들자.

```javascript
{
    xtype: 'form', // Ext.form.Panel
    layout: {
        type: 'vbox',
        align: 'stretch',
    },
    items: [{
        xtype: 'textfield',
        fieldLabel: '이름',
        labelAlign: 'right',
        name: 'name',
        reference: 'name'
    },{
        xtype: 'textfield',
        fieldLabel: '이메일',
        labelAlign: 'right',
        name: 'email',
        reference: 'email'
    },{
        xtype: 'textfield',
        fieldLabel: '전화번호',
        labelAlign: 'right',
        name: 'phone',
        reference: 'phone'
    }]
}
```
### 폼 데이터 서버로 전송하기
#### 폼 패널에 입력된 데이터를 서버로 전송하는 일반적인 방법은 폼 제출(form submit). 폼 제출은 주로 데이터 등록, 저장, 변경 작업에 사용됨.

### MVVM 바인딩과 레퍼런스 사용
#### Ext JS의 MVVM(`Model-View-ViewMode`l) 아키텍처에서는 데이터 바인딩을 활용하여 뷰모델의 데이터와 뷰 컴포넌트를 연결할 수 있음. 그러나 이 예제에서는 `lookupReference`를 사용하여 폼 필드에 접근하는 방식을 사용.

#### lookupReference 사용 이유: 편리하게 폼 필드에 접근할 수 있으며, 코드의 가독성과 유지보수성을 향상시킴. name 속성을 사용해도 접근이 가능하지만, `reference`를 사용함으로써 더 명확하고 직관적인 코드 작성이 가능.
### 폼 제출과 데이터 처리
#### 폼을 제출할 때는 `form.submit()` 메소드를 사용하거나, 컨트롤러에서 버튼 클릭 이벤트 핸들러 내에서 폼 데이터를 수집하여 `AJAX` 요청으로 서버로 전송할 수 있음. 서버에서는 전송받은 데이터를 처리한 후 적절한 응답을 반환.

### 결론
#### Ext JS에서 폼을 사용하여 데이터를 수집하고 서버로 전송하는 과정은 매우 직관적이며, `Ext.form.Panel`과 MVVM 아키텍처의 기능을 최대한 활용하여 효율적으로 구현할 수 있다. `lookupReference`와 같은 메소드를 사용하여 폼 필드에 접근하고 데이터를 처리하는 방식은 코드의 가독성과 유지보수성을 높여준다.

## 🌟 그리드 설정
#### 먼저, grid 컴포넌트를 설정. 이 그리드는 `MVVM` 패턴의 `bind` 속성을 사용하여 스토어와 바인딩됨. 각 컬럼은 `dataIndex`를 통해 표시할 데이터 필드를 지정.

```javascript
xtype: 'grid',
flex: 1,
bind: {
    store: '{personalInfo}'
},
columns: [{
    text: '이름',
    dataIndex: 'name',
    width: 100
}, {
    text: '이메일',
    dataIndex: 'email',
    flex: 1
}, {
    text: '전화번호',
    dataIndex: 'phone',
    flex: 1
}],
listeners: {
    itemclick: 'onGridClick'
}
```
### 🚀 컨트롤러에서 이벤트 처리
#### 그리드의 `itemclick` 이벤트에 반응하여 실행될 `onGridClick` 함수를 컨트롤러에 정의. 이 함수에서는 클릭된 아이템의 데이터를 가져와 폼 필드에 설정합니다.

```javascript
onGridClick: function(view, record) {
    let name = record.get('name');
    let email = record.get('email');
    let phone = record.get('phone');

    this.lookupReference('name').setValue(name);
    this.lookupReference('email').setValue(email);
    this.lookupReference('phone').setValue(phone);
}
```
### 📌 arguments 로그 찍기의 중요성
#### 함수의 파라미터가 불확실하거나 함수가 어떤 인자들을 받는지 확인하고 싶을 때, `console.log('arguments =', arguments);`를 사용하여 현재 함수에 전달된 모든 인자들을 콘솔에 출력할 수 있다. 이 방법은 함수의 동작을 이해하고 디버깅할 때 매우 유용하다.

```javascript
onGridClick: function(panel, records) {
    console.log('arguments =', arguments);
    // 함수 내 로직...
}
```
### 🎯 자동화된 데이터 바인딩 구현
#### 위에서 설명한 방식은 선택된 레코드의 데이터를 수동으로 폼 필드에 설정하는 방법. 이 과정을 자동화하려면, 공통된 처리 로직을 가진 부모 컨트롤러를 만들고, 필요한 뷰 컨트롤러에서 이를 상속받아 사용할 수 있다. 상속받은 컨트롤러에서는 `onGridClick`과 같은 이벤트 처리 로직을 통해, 선택된 레코드 데이터를 폼에 자동으로 채워넣는 공통 메서드를 호출할 수 있다.


### 📖 결론
#### Ext JS에서 그리드 아이템 클릭 이벤트를 활용하여 데이터를 폼에 자동으로 채우는 과정은, 사용자 경험을 풍부하게 만들고, 데이터 관리를 효율적으로 할 수 있는 좋은 방법. `arguments`를 로그에 찍는 실습을 통해 함수의 작동 방식을 더 잘 이해할 수 있으며, 이벤트 처리와 데이터 바인딩을 자동화하여 코드의 재사용성과 유지보수성을 높일 수 있음.

## 폼 아래에 버튼 추가하기 🛠
#### 폼 제출을 위해서는 사용자가 클릭할 수 있는 '제출(`Submit`)' 버튼이 필요합니다. Ext JS에서는 이를 위해 `xtype: 'button'`과 `handler` 속성을 사용하여 폼 아래쪽에 버튼을 배치할 수 있다.

```javascript
xtype: 'form', // 폼 패널 정의 📝
reference: 'detailPanel', // 폼을 쉽게 찾기 위한 참조 이름 🏷
items: [
    // 폼 필드들이 여기에 위치합니다. 예: 이름, 이메일, 전화번호 필드 등 📋
],
bbar: [ // 폼의 바닥 부분에 버튼 추가 🎯
    '->', // 버튼을 오른쪽으로 정렬하기 위한 설정 🔄
    {
        xtype: 'button', // 버튼 정의 🖱
        text: 'Submit', // 버튼에 표시될 텍스트 📄
        handler: 'onSubmitForm' // 버튼 클릭 시 실행될 함수 이름 🔨
    }
]
```
### 폼 데이터 서버로 제출하기 📤
#### 제출 버튼을 클릭했을 때, 폼 데이터를 서버로 제출하는 과정. 이를 위해 `onSubmitForm` 이라는 함수를 정의하고, 폼 데이터를 서버로 제출.

```javascript
onSubmitForm: function() {
    let form = this.lookupReference('detailPanel').getForm(); // 폼 참조 가져오기 🔍
    form.submit({ // 폼 제출 메서드 호출 🚀
        url: './service/form.json', // 데이터를 받을 서버의 URL 🌐
        success: function(form, action) { // 제출 성공 시 실행될 콜백 함수 ✅
            Ext.Msg.alert('성공', '변경했습니다!'); // 성공 알림 메시지 🎉
        },
        failure: function(form, action) { // 제출 실패 시 실행될 콜백 함수 ❌
            // 실패 처리 로직 (예: 에러 메시지 표시)
        }
    });
}
```
### 폼 제출에 대한 이해 📚
#### 위 코드에서는 Ext JS의 폼 패널을 사용하여 사용자로부터 데이터를 입력받고, '제출(`Submit`)' 버튼을 통해 해당 데이터를 서버로 제출하는 과정을 설명. 폼 제출은 일반적으로 사용자가 입력한 데이터를 저장하거나 서버에서 처리해야 할 작업에 사용됨.

#### 이 과정을 통해, Ext JS 애플리케이션에서 사용자 입력을 받고, 이를 서버로 전송하여 필요한 작업을 수행할 수 있고. 이는 웹 애플리케이션에서 데이터 관리와 서버와의 상호작용에 필수적인 부분이다. 🌍

## 폼 제출 콜백 함수에 대한 이해 📚
Ext JS에서 폼(`Ext.form.Panel`)을 서버로 제출(`submit`)할 때 사용되는 메커니즘에는 주요 두 가지 매개변수, `form`과 `action`, 가 있다. 각각의 역할과 중요성에 대해 알아보자.

### 🖊 form 매개변수
#### `form `매개변수는 폼 제출이 발생한 `Ext.form.Panel` 인스턴스를 참조합니다. 📌
#### 개발자는 이를 통해 폼 객체에 접근하고, 폼의 현재 상태나 데이터, 폼 내 필드와 메소드 등을 사용할 수 있다. 🛠
#### 폼 제출 후에도 폼 객체를 조작하거나 정보를 얻기 위해 사용. 🔄
### 📡 action 매개변수
#### `action` 매개변수는 서버로부터 받은 응답에 대한 정보를 담고 있는 객체. 🌐
#### 이 객체를 통해 서버 응답의 성공 여부, 서버에서 반환된 데이터(`action.result`), 에러 메시지 등을 접근할 수 있다. 🔍
#### 폼 제출의 성공 여부에 따라 다음 작업을 결정하는 데 필수적인 정보를 제공. ✔️
### 폼 제출 콜백 함수 예시 📄
```javascript
form.submit({
    success: function(form, action) {
        // 폼 제출 성공 시 실행 🎉
        Ext.Msg.alert('성공', '변경했습니다!');
        var responseData = action.result; // 서버에서 반환된 데이터 접근 📊
    },
    failure: function(form, action) {
        // 폼 제출 실패 시 실행 😢
        Ext.Msg.alert('실패', '서버 오류 발생');
    }
});
```
### 왜 매개변수가 두 개일까요? 🤔
#### `form`과 `action` 두 매개변수는 서로 다른 목적을 가지고 있기 때문에. 🎯
#### `form`을 통해 폼 객체와 상호작용하고, `action`을 통해 서버 응답을 처리. 🖥 <-> 📱
#### 폼 제출 과정에서 이 두 가지 측면 모두 중요하기 때문에, Ext JS는 두 매개변수를 모두 콜백 함수에 전달. 🔄
### 결론 🌟
#### Ext JS에서 폼 제출의 `success`와 `failur`e` 콜백에서 `form`과 `action` 매개변수를 제공하는 것은 개발자가 폼 객체를 자유롭게 다루고, 서버 응답을 효과적으로 처리할 수 있도록 하기 위함이다. 이를 통해 개발자는 폼 제출 후에도 필요한 작업을 유연하게 수행할 수 있으며, 사용자에게 적절한 피드백을 제공할 수 있다. 🚀

### Ext.Ajax와 직접적인 데이터 처리 🛠
#### 기본적으로 Ext JS의 `Ext.Ajax`는 자바스크립트의 `XMLHttpRequest`를 추상화한 것으로, 서버와의 비동기 통신을 담당.
#### 데이터 변환: 개발자가 직접 요청을 보낼 때는 데이터 형태(예: `JSON, XML`)를 직접 지정하고, 서버로부터 받은 응답 데이터도 직접 파싱하여 사용해야 한다. 이 과정에서 모든 데이터 처리를 수동으로 관리해야 한다는 것이 특징.
#### 사용 예시:
```javascript
Ext.Ajax.request({
    url: 'your-server-endpoint', // 서버 URL
    method: 'POST', // HTTP 메소드
    params: { // 서버로 보낼 파라미터
        key: 'value'
    },
    success: function(response) { // 성공 시 콜백
        var data = Ext.decode(response.responseText); // 응답 파싱
        // 데이터 처리 로직
    },
    failure: function() { // 실패 시 콜백
        // 에러 처리 로직
    }
});
```
### 스토어와 폼: 약속된 프로토콜 형식 📦
- #### 스토어: 데이터 컬렉션을 관리하고, 모델(`Model`)을 통해 데이터의 구조를 정의하며, 프록시(Proxy)를 통해 서버와의 데이터 교환 방식을 설정.
#### 스토어와 서버 간의 통신은 주로 `JSON` 형식으로 이루어집니다. 스토어가 자동으로 데이터를 객체화하고, `CRUD(Create, Read, Update, Delete)` 연산에 필요한 요청을 서버에 보냄.
- #### 폼(Form): 사용자로부터 입력받은 데이터를 서버로 전송하는 용도로 사용. `Ext.form.Panel`은 내부적으로 폼 데이터를 적절한 형식으로 인코딩하고, 유효성 검사를 자동으로 수행한 후 서버로 제출.
#### 폼 데이터는 일반적으로 `name` 속성을 기반으로 서버로 전송되며, 서버 응답 역시 약속된 형식(보통 `JSON`)에 따라 처리됩니다.
### 결론 🌈
#### `Ext.Ajax` 사용 시, 모든 데이터 처리 과정(인코딩, 디코딩, 데이터 형식 지정)을 개발자가 직접 관리해야 함. 이는 유연성은 높지만, 더 많은 코딩 작업이 필요...
#### 스토어와 폼을 사용하면, Ext JS가 데이터 형식과 통신 프로토콜에 대한 처리를 대부분 자동으로 관리해줌. 이는 개발 과정을 간소화시키고, 일관된 방식으로 서버 통신을 구현할 수 있게 해준다.
#### 즉, `Ext.Ajax`는 맞춤형 통신 로직이 필요할 때, 스토어와 폼은 `Ext JS`의 표준 기능을 이용해 효율적으로 데이터 관리를 하고자 할 때 유용하게 사용하면된다.
---




















































































































    


























      





























